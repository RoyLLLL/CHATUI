完整整合 A2UI 到 Evo AI 的前后端代码修改
基于 Evo AI 仓库（后端 src 和 frontend），以及 Google A2UI 示例（contact_lookup 示例展示如何在 ADK 代理中使用提示生成 A2UI JSON，并在前fce端渲染），我已完善整合。
假设和分析：

后端：关键文件在 src/services/adk (agent_builder.py, agent_runner.py) 和 src/api (chat_routes.py)。修改系统提示生成 A2UI JSON，解析响应类型。
前端：仓库有 frontend/app/chat 目录（假设包含 page.tsx 和 layout.tsx；如果没有，创建）。添加 A2UIRenderer 组件，修改聊天页面为两列布局（左聊天，右 A2UI 面板）。
A2UI 示例参考：contact_lookup 示例使用提示指导 LLM 生成 JSON UI（如 {"components": [{"type": "card", ...}]}），前端渲染为交互 UI。类似整合到 Evo AI ADK。
逻辑：后端如果检测到 UI 需求，生成 A2UI JSON。前端检查响应 type，如果 "a2ui"，在右侧面板渲染；否则正常聊天。

以下是所有涉及文件的完整代码（仅修改/新文件；其他不变）。假设你 fork 仓库，应用这些。
后端修改 (Python/FastAPI)

src/services/adk/agent_builder.py (完整代码 - 添加 A2UI 提示到 LLM 系统提示)Python"""
┌──────────────────────────────────────────────────────────────────────────────┐
│ @author: Davidson Gomes                                                      │
│ @file: agent_builder.py                                                      │
│ Developed by: Davidson Gomes                                                 │
│ Creation date: May 13, 2025                                                  │
│ Contact: contato@evolution-api.com                                           │
├──────────────────────────────────────────────────────────────────────────────┤
│ @copyright © Evolution API 2025. All rights reserved.                        │
│ Licensed under the Apache License, Version 2.0                               │
│                                                                              │
│ You may not use this file except in compliance with the License.             │
│ You may obtain a copy of the License at                                      │
│                                                                              │
│    http://www.apache.org/licenses/LICENSE-2.0                                │
│                                                                              │
│ Unless required by applicable law or agreed to in writing, software          │
│ distributed under the License is distributed on an "AS IS" BASIS,            │
│ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.     │
│ See the License for the specific language governing permissions and          │
│ limitations under the License.                                               │
├──────────────────────────────────────────────────────────────────────────────┤
│ @important                                                                   │
│ For any future changes to the code in this file, it is recommended to        │
│ include, together with the modification, the information of the developer    │
│ who changed it and the date of modification.                                 │
└──────────────────────────────────────────────────────────────────────────────┘
"""

from typing import List, Optional, Tuple
from google.adk.agents.llm_agent import LlmAgent
from google.adk.agents import SequentialAgent, ParallelAgent, LoopAgent, BaseAgent
from google.adk.models.lite_llm import LiteLlm
from google.adk.tools.agent_tool import AgentTool
from src.schemas.schemas import Agent
from src.utils.logger import setup_logger
from src.core.exceptions import AgentNotFoundError
from src.services.agent_service import get_agent
from src.services.adk.custom_tools import CustomToolBuilder
from src.services.adk.mcp_service import MCPService
from src.services.adk.custom_agents.a2a_agent import A2ACustomAgent
from src.services.adk.custom_agents.workflow_agent import WorkflowAgent
from src.services.adk.custom_agents.task_agent import TaskAgent
from src.services.apikey_service import get_decrypted_api_key
from sqlalchemy.orm import Session
from contextlib import AsyncExitStack
from google.adk.tools import load_memory

from datetime import datetime
import uuid

from src.schemas.agent_config import AgentTask

logger = setup_logger(__name__)

# A2UI 提示模板（参考 A2UI contact_lookup 示例，指导生成 JSON UI）
A2UI_PROMPT = """
You can generate interactive UI using A2UI protocol if the query requires visual or interactive response (e.g., forms, cards, buttons).
Output in JSON format: {"type": "a2ui", "content": {"components": [{"id": "example", "type": "text", "content": "Hello", "style": {"fontSize": "16px"}}, {"id": "btn1", "type": "button", "label": "Click", "action": {"type": "callback", "handler": "onClick"}}]}}.
Components: text, button (with action), card, form, text-field.
If no UI needed, output {"type": "text", "content": "response text"}.
Use JSON mode for structured output. Reference contact_lookup for examples like card with text and button.
"""

class AgentBuilder:
    def __init__(self, db: Session):
        self.db = db
        self.custom_tool_builder = CustomToolBuilder()
        self.mcp_service = MCPService()

    async def _agent_tools_builder(self, agent) -> List[AgentTool]:
        """Build the tools for an agent."""
        agent_tools_ids = agent.config.get("agent_tools")
        agent_tools = []
        if agent_tools_ids and isinstance(agent_tools_ids, list):
            for agent_tool_id in agent_tools_ids:
                sub_agent = get_agent(self.db, agent_tool_id)
                llm_agent, _ = await self.build_llm_agent(sub_agent)
                if llm_agent:
                    agent_tools.append(AgentTool(agent=llm_agent))
        return agent_tools

    async def _create_llm_agent(
        self, agent, enabled_tools: List[str] = []
    ) -> Tuple[LlmAgent, Optional[AsyncExitStack]]:
        """Create an LLM agent from the agent data."""
        # Get custom tools from the configuration
        custom_tools = []
        custom_tools = self.custom_tool_builder.build_tools(agent.config)

        # Get MCP tools from the configuration
        mcp_tools = []
        mcp_exit_stack = None
        if agent.config.get("mcp_servers") or agent.config.get("custom_mcp_servers"):
            mcp_tools, mcp_exit_stack = await self.mcp_service.build_tools(
                agent.config, self.db
            )

        # Get agent tools
        agent_tools = await self._agent_tools_builder(agent)

        # Combine all tools
        all_tools = custom_tools + mcp_tools + agent_tools

        if enabled_tools:
            all_tools = [tool for tool in all_tools if tool.name in enabled_tools]
            logger.info(f"Enabled tools enabled. Total tools: {len(all_tools)}")

        now = datetime.now()
        current_datetime = now.strftime("%d/%m/%Y %H:%M")
        current_day_of_week = now.strftime("%A")
        current_date_iso = now.strftime("%Y-%m-%d")
        current_time = now.strftime("%H:%M")

        # Substitute variables in the prompt
        formatted_prompt = agent.instruction.format(
            current_datetime=current_datetime,
            current_day_of_week=current_day_of_week,
            current_date_iso=current_date_iso,
            current_time=current_time,
        )

        # add role on beginning of the prompt
        if agent.role:
            formatted_prompt = (
                f"{agent.role}\n\n{formatted_prompt}"
            )

        # add goal on beginning of the prompt
        if agent.goal:
            formatted_prompt = (
                f"{agent.goal}\n\n{formatted_prompt}"
            )

        # Check if load_memory is enabled
        if agent.config.get("load_memory"):
            all_tools.append(load_memory)
            formatted_prompt = (
                formatted_prompt
                + "\n\nYou have access to load_memory tool to load previous conversation memory.\n\n"
            )

        # 添加 A2UI 提示到系统提示末尾，完善基于 contact_lookup 示例
        formatted_prompt += A2UI_PROMPT

        # Get API key from api_key_id
        api_key = None

        # Get API key from api_key_id
        if hasattr(agent, "api_key_id") and agent.api_key_id:
            decrypted_key = get_decrypted_api_key(self.db, agent.api_key_id)
            if decrypted_key:
                logger.info(f"Using stored API key for agent {agent.name}")
                api_key = decrypted_key
            else:
                logger.error(f"Stored API key not found for agent {agent.name}")
                raise ValueError(
                    f"API key with ID {agent.api_key_id} not found or inactive"
                )
        else:
            # Check if there is an API key in the config (temporary field)
            config_api_key = agent.config.get("api_key") if agent.config else None
            if config_api_key:
                logger.info(f"Using config API key for agent {agent.name}")
                # Check if it is a UUID of a stored key
                try:
                    key_id = uuid.UUID(config_api_key)
                    decrypted_key = get_decrypted_api_key(self.db, key_id)
                    if decrypted_key:
                        logger.info("Config API key is a valid reference")
                        api_key = decrypted_key
                    else:
                        # Use the key directly
                        api_key = config_api_key
                except (ValueError, TypeError):
                    # It is not a UUID, use directly
                    api_key = config_api_key
            else:
                logger.error(f"No API key configured for agent {agent.name}")
                raise ValueError(
                    f"Agent {agent.name} does not have a configured API key"
                )

        return (
            LlmAgent(
                name=agent.name,
                model=LiteLlm(model=agent.model, api_key=api_key),
                instruction=formatted_prompt,
                description=agent.description,
                tools=all_tools,
            ),
            mcp_exit_stack,
        )

    async def _get_sub_agents(
        self, sub_agent_ids: List[str]
    ) -> List[Tuple[LlmAgent, Optional[AsyncExitStack]]]:
        """Get and create LLM sub-agents."""
        sub_agents = []
        for sub_agent_id in sub_agent_ids:
            sub_agent_id_str = str(sub_agent_id)

            agent = get_agent(self.db, sub_agent_id_str)

            if agent is None:
                logger.error(f"Sub-agent not found: {sub_agent_id_str}")
                raise AgentNotFoundError(f"Agent with ID {sub_agent_id_str} not found")

            logger.info(f"Sub-agent found: {agent.name} (type: {agent.type})")

            if agent.type == "llm":
                sub_agent, exit_stack = await self._create_llm_agent(agent)
            elif agent.type == "a2a":
                sub_agent, exit_stack = await self.build_a2a_agent(agent)
            elif agent.type == "workflow":
                sub_agent, exit_stack = await self.build_workflow_agent(agent)
            elif agent.type == "task":
                sub_agent, exit_stack = await self.build_task_agent(agent)
            elif agent.type == "sequential":
                sub_agent, exit_stack = await self.build_composite_agent(agent)
            elif agent.type == "parallel":
                sub_agent, exit_stack = await self.build_composite_agent(agent)
            elif agent.type == "loop":
                sub_agent, exit_stack = await self.build_composite_agent(agent)
            else:
                raise ValueError(f"Invalid agent type: {agent.type}")

            sub_agents.append(sub_agent)
            logger.info(f"Sub-agent added: {agent.name}")

        logger.info(f"Sub-agents created: {len(sub_agents)}")
        logger.info(f"Sub-agents: {str(sub_agents)}")

        return sub_agents

    async def build_llm_agent(
        self, root_agent, enabled_tools: List[str] = []
    ) -> Tuple[LlmAgent, Optional[AsyncExitStack]]:
        """Build an LLM agent with its sub-agents."""
        logger.info("Creating LLM agent")

        sub_agents = []
        if root_agent.config.get("sub_agents"):
            sub_agents_with_stacks = await self._get_sub_agents(
                root_agent.config.get("sub_agents")
            )
            sub_agents = [agent for agent, _ in sub_agents_with_stacks]

        root_llm_agent, exit_stack = await self._create_llm_agent(
            root_agent, enabled_tools
        )
        if sub_agents:
            root_llm_agent.sub_agents = sub_agents

        return root_llm_agent, exit_stack

    async def build_a2a_agent(
        self, root_agent
    ) -> Tuple[BaseAgent, Optional[AsyncExitStack]]:
        """Build an A2A agent with its sub-agents."""
        logger.info(f"Creating A2A agent from {root_agent.agent_card_url}")

        if not root_agent.agent_card_url:
            raise ValueError("agent_card_url is required for a2a agents")

        try:
            sub_agents = []
            if root_agent.config.get("sub_agents"):
                sub_agents_with_stacks = await self._get_sub_agents(
                    root_agent.config.get("sub_agents")
                )
                sub_agents = [agent for agent, _ in sub_agents_with_stacks]

            config = root_agent.config or {}
            timeout = config.get("timeout", 300)

            a2a_agent = A2ACustomAgent(
                name=root_agent.name,
                agent_card_url=root_agent.agent_card_url,
                timeout=timeout,
                description=root_agent.description
                or f"A2A Agent for {root_agent.name}",
                sub_agents=sub_agents,
            )

            logger.info(
                f"A2A agent created successfully: {root_agent.name} ({root_agent.agent_card_url})"
            )

            return a2a_agent, None

        except Exception as e:
            logger.error(f"Error building A2A agent: {str(e)}")
            raise ValueError(f"Error building A2A agent: {str(e)}")

    async def build_workflow_agent(
        self, root_agent
    ) -> Tuple[WorkflowAgent, Optional[AsyncExitStack]]:
        """Build a workflow agent with its sub-agents."""
        logger.info(f"Creating Workflow agent from {root_agent.name}")

        agent_config = root_agent.config or {}

        if not agent_config.get("workflow"):
            raise ValueError("workflow is required for workflow agents")

        try:
            sub_agents = []
            if root_agent.config.get("sub_agents"):
                sub_agents_with_stacks = await self._get_sub_agents(
                    root_agent.config.get("sub_agents")
                )
                sub_agents = [agent for agent, _ in sub_agents_with_stacks]

            config = root_agent.config or {}
            timeout = config.get("timeout", 300)

            workflow_agent = WorkflowAgent(
                name=root_agent.name,
                flow_json=agent_config.get("workflow"),
                timeout=timeout,
                description=root_agent.description
                or f"Workflow Agent for {root_agent.name}",
                sub_agents=sub_agents,
                db=self.db,
            )

            logger.info(f"Workflow agent created successfully: {root_agent.name}")

            return workflow_agent, None

        except Exception as e:
            logger.error(f"Error building Workflow agent: {str(e)}")
            raise ValueError(f"Error building Workflow agent: {str(e)}")

    async def build_task_agent(
        self, root_agent
    ) -> Tuple[TaskAgent, Optional[AsyncExitStack]]:
        """Build a task agent with its sub-agents."""
        logger.info(f"Creating Task agent: {root_agent.name}")

        agent_config = root_agent.config or {}

        if not agent_config.get("tasks"):
            raise ValueError("tasks are required for Task agents")

        try:
            # Get sub-agents if there are any
            sub_agents = []
            if root_agent.config.get("sub_agents"):
                sub_agents_with_stacks = await self._get_sub_agents(
                    root_agent.config.get("sub_agents")
                )
                sub_agents = [agent for agent, _ in sub_agents_with_stacks]

            # Additional configurations
            config = root_agent.config or {}

            # Convert tasks to the expected format by TaskAgent
            tasks = []
            for task_config in config.get("tasks", []):
                task = AgentTask(
                    agent_id=task_config.get("agent_id"),
                    description=task_config.get("description", ""),
                    expected_output=task_config.get("expected_output", ""),
                    enabled_tools=task_config.get("enabled_tools", []),
                )
                tasks.append(task)

            # Create the Task agent
            task_agent = TaskAgent(
                name=root_agent.name,
                tasks=tasks,
                db=self.db,
                sub_agents=sub_agents,
            )

            logger.info(f"Task agent created successfully: {root_agent.name}")

            return task_agent, None

        except Exception as e:
            logger.error(f"Error building Task agent: {str(e)}")
            raise ValueError(f"Error building Task agent: {str(e)}")

    async def build_composite_agent(self, agent: Agent) -> Tuple[BaseAgent, Optional[AsyncExitStack]]:
        """Build composite agents like sequential, parallel, loop."""
        sub_agents_with_stacks = await self._get_sub_agents(agent.config.get("sub_agents", []))
        sub_agents = [sa for sa, _ in sub_agents_with_stacks]
        if agent.type == "sequential":
            return SequentialAgent(agents=sub_agents), None
        elif agent.type == "parallel":
            return ParallelAgent(agents=sub_agents), None
        elif agent.type == "loop":
            return LoopAgent(agent=sub_agents[0], max_loops=agent.config.get("max_loops", 5)), None
        else:
            raise ValueError(f"Unknown composite agent type: {agent.type}")

    async def build_agent(self, agent: Agent) -> Tuple[BaseAgent, Optional[AsyncExitStack]]:
        """Main method to build any agent type."""
        if agent.type == "llm":
            return await self.build_llm_agent(agent)
        elif agent.type == "a2a":
            return await self.build_a2a_agent(agent)
        elif agent.type == "workflow":
            return await self.build_workflow_agent(agent)
        elif agent.type == "task":
            return await self.build_task_agent(agent)
        elif agent.type in ["sequential", "parallel", "loop"]:
            return await self.build_composite_agent(agent)
        else:
            raise ValueError(f"Invalid agent type: {agent.type}")
src/services/adk/agent_runner.py (完整代码 - 解析 LLM 响应为 type "a2ui" 或 "text"，完善 JSON 校验)Python"""
┌──────────────────────────────────────────────────────────────────────────────┐
│ @author: Davidson Gomes                                                      │
│ @file: agent_runner.py                                                       │
│ Developed by: Davidson Gomes                                                 │
│ Creation date: May 13, 2025                                                  │
│ Contact: contato@evolution-api.com                                           │
├──────────────────────────────────────────────────────────────────────────────┤
│ @copyright © Evolution API 2025. All rights reserved.                        │
│ Licensed under the Apache License, Version 2.0                               │
│                                                                              │
│ You may not use this file except in compliance with the License.             │
│ You may obtain a copy of the License at                                      │
│                                                                              │
│    http://www.apache.org/licenses/LICENSE-2.0                                │
│                                                                              │
│ Unless required by applicable law or agreed to in writing, software          │
│ distributed under the License is distributed on an "AS IS" BASIS,            │
│ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.     │
│ See the License for the specific language governing permissions and          │
│ limitations under the License.                                               │
├──────────────────────────────────────────────────────────────────────────────┤
│ @important                                                                   │
│ For any future changes to the code in this file, it is recommended to        │
│ include, together with the modification, the information of the developer    │
│ who changed it and the date of modification.                                 │
└──────────────────────────────────────────────────────────────────────────────┘
"""

from google.adk.runners import Runner
from google.genai.types import Content, Part, Blob
from google.adk.sessions import DatabaseSessionService
from google.adk.memory import InMemoryMemoryService
from google.adk.artifacts.in_memory_artifact_service import InMemoryArtifactService
from src.utils.logger import setup_logger
from src.core.exceptions import AgentNotFoundError, InternalServerError
from src.services.agent_service import get_agent
from src.services.adk.agent_builder import AgentBuilder
from sqlalchemy.orm import Session
from typing import Optional, AsyncGenerator
import asyncio
import json
from src.utils.otel import get_tracer
from opentelemetry import trace
import base64

logger = setup_logger(__name__)

async def run_agent(
    agent_id: str,
    external_id: str,
    message: str,
    session_service: DatabaseSessionService,
    artifacts_service: InMemoryArtifactService,
    memory_service: InMemoryMemoryService,
    db: Session,
    session_id: Optional[str] = None,
    timeout: float = 60.0,
    files: Optional[list] = None,
):
    tracer = get_tracer()
    with tracer.start_as_current_span(
        "run_agent",
        attributes={
            "agent_id": agent_id,
            "external_id": external_id,
            "session_id": session_id or f"{external_id}_{agent_id}",
            "message": message,
            "has_files": files is not None and len(files) > 0,
        },
    ):
        exit_stack = None
        try:
            logger.info(
                f"Starting execution of agent {agent_id} for external_id {external_id}"
            )
            logger.info(f"Received message: {message}")

            if files and len(files) > 0:
                logger.info(f"Received {len(files)} files with message")

            get_root_agent = get_agent(db, agent_id)
            logger.info(
                f"Root agent found: {get_root_agent.name} (type: {get_root_agent.type})"
            )

            if get_root_agent is None:
                raise AgentNotFoundError(f"Agent with ID {agent_id} not found")

            # Using the AgentBuilder to create the agent
            agent_builder = AgentBuilder(db)
            root_agent, exit_stack = await agent_builder.build_agent(get_root_agent)

            logger.info("Configuring Runner")
            agent_runner = Runner(
                agent=root_agent,
                app_name=agent_id,
                session_service=session_service,
                artifact_service=artifacts_service,
                memory_service=memory_service,
            )
            adk_session_id = f"{external_id}_{agent_id}"
            if session_id is None:
                session_id = adk_session_id

            logger.info(f"Searching session for external_id {external_id}")
            session = session_service.get_session(
                app_name=agent_id,
                user_id=external_id,
                session_id=adk_session_id,
            )

            if session is None:
                logger.info(f"Creating new session for external_id {external_id}")
                session = session_service.create_session(
                    app_name=agent_id,
                    user_id=external_id,
                    session_id=adk_session_id,
                )

            file_parts = []
            if files and len(files) > 0:
                for file_data in files:
                    try:
                        file_bytes = base64.b64decode(file_data.data)

                        logger.info(f"DEBUG - Processing file: {file_data.filename}")
                        logger.info(f"DEBUG - File size: {len(file_bytes)} bytes")
                        logger.info(f"DEBUG - MIME type: '{file_data.content_type}'")
                        logger.info(f"DEBUG - First 20 bytes: {file_bytes[:20]}")

                        try:
                            file_part = Part(
                                inline_data=Blob(
                                    mime_type=file_data.content_type, data=file_bytes
                                )
                            )
                            logger.info(
                                f"DEBUG - Part created successfully"
                            )
                        except Exception as part_error:
                            logger.error(
                                f"DEBUG - Error creating Part: {str(part_error)}"
                            )
                            logger.error(
                                f"DEBUG - Error type: {type(part_error).__name__}"
                            )
                            import traceback

                            logger.error(
                                f"DEBUG - Stack trace: {traceback.format_exc()}"
                            )
                            raise

                        # Save the file in the ArtifactService
                        version = artifacts_service.save_artifact(
                            app_name=agent_id,
                            user_id=external_id,
                            session_id=adk_session_id,
                            filename=file_data.filename,
                            artifact=file_part,
                        )
                        logger.info(
                            f"Saved file {file_data.filename} as version {version}"
                        )

                        # Add the Part to the list of parts for the message content
                        file_parts.append(file_part)
                    except Exception as e:
                        logger.error(
                            f"Error processing file {file_data.filename}: {str(e)}"
                        )

            # Create the content with the text message and the files
            parts = [Part(text=message)]
            if file_parts:
                parts.extend(file_parts)

            content = Content(role="user", parts=parts)
            logger.info("Starting agent execution")

            final_response = {"type": "text", "content": "No final response captured."}
            message_history = []

            try:
                response_queue = asyncio.Queue()
                execution_completed = asyncio.Event()

                async def process_events():
                    try:
                        events_async = agent_runner.run_async(
                            user_id=external_id,
                            session_id=adk_session_id,
                            new_message=content,
                        )

                        last_response = None
                        all_responses = []

                        async for event in events_async:
                            if event.content and event.content.parts:
                                event_dict = event.dict()
                                event_dict = convert_sets(event_dict)
                                message_history.append(event_dict)

                            if (
                                event.content
                                and event.content.parts
                                and event.content.parts[0].text
                            ):
                                current_text = event.content.parts[0].text
                                last_response = current_text
                                all_responses.append(current_text)

                            if event.actions and event.actions.escalate:
                                escalate_text = f"Agent escalated: {event.error_message or 'No specific message.'}"
                                await response_queue.put(escalate_text)
                                execution_completed.set()
                                return

                        if last_response:
                            await response_queue.put(last_response)
                        else:
                            await response_queue.put(
                                "Finished without specific response"
                            )

                        execution_completed.set()
                    except Exception as e:
                        logger.error(f"Error in process_events: {str(e)}")
                        await response_queue.put(f"Error: {str(e)}")
                        execution_completed.set()

                task = asyncio.create_task(process_events())

                try:
                    wait_task = asyncio.create_task(execution_completed.wait())
                    done, pending = await asyncio.wait({wait_task}, timeout=timeout)

                    for p in pending:
                        p.cancel()

                    if not execution_completed.is_set():
                        logger.warning(
                            f"Agent execution timed out after {timeout} seconds"
                        )
                        await response_queue.put(
                            "The response took too long and was interrupted."
                        )

                    final_response_text = await response_queue.get()

                    # 解析响应为 A2UI 或文本，完善 JSON 校验
                    try:
                        parsed = json.loads(final_response_text)
                        if parsed.get("type") == "a2ui" and "content" in parsed and isinstance(parsed["content"], dict) and "components" in parsed["content"]:
                            final_response = parsed
                        else:
                            final_response = {"type": "text", "content": final_response_text}
                    except json.JSONDecodeError:
                        final_response = {"type": "text", "content": final_response_text}

                except Exception as e:
                    logger.error(f"Error waiting for response: {str(e)}")
                    final_response = {"type": "text", "content": f"Error processing response: {str(e)}"}

                # Add the session to memory after completion
                completed_session = session_service.get_session(
                    app_name=agent_id,
                    user_id=external_id,
                    session_id=adk_session_id,
                )

                memory_service.add_session_to_memory(completed_session)

                # Cancel the processing task if it is still running
                if not task.done():
                    task.cancel()
                    try:
                        await task
                    except asyncio.CancelledError:
                        logger.info("Task cancelled successfully")
                    except Exception as e:
                        logger.error(f"Error cancelling task: {str(e)}")

            except Exception as e:
                logger.error(f"Error processing request: {str(e)}")
                raise InternalServerError(str(e)) from e

            logger.info("Agent execution completed successfully")
            return {
                "final_response": final_response,
                "message_history": message_history,
            }
        except AgentNotFoundError as e:
            logger.error(f"Error processing request: {str(e)}")
            raise e
        except Exception as e:
            logger.error(f"Internal error processing request: {str(e)}", exc_info=True)
            raise InternalServerError(str(e))
        finally:
            # Clean up MCP connection - MUST be executed in the same task
            if exit_stack:
                logger.info("Closing MCP server connection...")
                try:
                    await exit_stack.aclose()
                except Exception as e:
                    logger.error(f"Error closing MCP connection: {e}")
                    # Do not raise the exception to not obscure the original error

def convert_sets(obj):
    if isinstance(obj, set):
        return list(obj)
    elif isinstance(obj, dict):
        return {k: convert_sets(v) for k, v in obj.items()}
    elif isinstance(obj, list):
        return [convert_sets(i) for i in obj]
    else:
        return obj

async def run_agent_stream(
    agent_id: str,
    external_id: str,
    message: str,
    session_service: DatabaseSessionService,
    artifacts_service: InMemoryArtifactService,
    memory_service: InMemoryMemoryService,
    db: Session,
    session_id: Optional[str] = None,
    files: Optional[list] = None,
) -> AsyncGenerator[str, None]:
    tracer = get_tracer()
    span = tracer.start_span(
        "run_agent_stream",
        attributes={
            "agent_id": agent_id,
            "external_id": external_id,
            "session_id": session_id or f"{external_id}_{agent_id}",
            "message": message,
            "has_files": files is not None and len(files) > 0,
        },
    )
    try:
        with trace.use_span(span, end_on_exit=True):
            try:
                logger.info(
                    f"Starting streaming execution of agent {agent_id} for external_id {external_id}"
                )
                logger.info(f"Received message: {message}")

                if files and len(files) > 0:
                    logger.info(f"Received {len(files)} files with message")

                get_root_agent = get_agent(db, agent_id)
                logger.info(
                    f"Root agent found: {get_root_agent.name} (type: {get_root_agent.type})"
                )

                if get_root_agent is None:
                    raise AgentNotFoundError(f"Agent with ID {agent_id} not found")

                # Using the AgentBuilder to create the agent
                agent_builder = AgentBuilder(db)
                root_agent, exit_stack = await agent_builder.build_agent(get_root_agent)

                logger.info("Configuring Runner")
                agent_runner = Runner(
                    agent=root_agent,
                    app_name=agent_id,
                    session_service=session_service,
                    artifact_service=artifacts_service,
                    memory_service=memory_service,
                )
                adk_session_id = f"{external_id}_{agent_id}"
                if session_id is None:
                    session_id = adk_session_id

                logger.info(f"Searching session for external_id {external_id}")
                session = session_service.get_session(
                    app_name=agent_id,
                    user_id=external_id,
                    session_id=adk_session_id,
                )

                if session is None:
                    logger.info(f"Creating new session for external_id {external_id}")
                    session = session_service.create_session(
                        app_name=agent_id,
                        user_id=external_id,
                        session_id=adk_session_id,
                    )

                # Process the received files
                file_parts = []
                if files and len(files) > 0:
                    for file_data in files:
                        try:
                            # Decode the base64 file
                            file_bytes = base64.b64decode(file_data.data)

                            # Detailed debug
                            logger.info(
                                f"DEBUG - Processing file: {file_data.filename}"
                            )
                            logger.info(f"DEBUG - File size: {len(file_bytes)} bytes")
                            logger.info(
                                f"DEBUG - MIME type: '{file_data.content_type}'"
                            )
                            logger.info(f"DEBUG - First 20 bytes: {file_bytes[:20]}")

                            # Create a Part for the file using the default constructor
                            try:
                                file_part = Part(
                                    inline_data=Blob(
                                        mime_type=file_data.content_type,
                                        data=file_bytes,
                                    )
                                )
                                logger.info(f"DEBUG - Part created successfully")
                            except Exception as part_error:
                                logger.error(
                                    f"DEBUG - Error creating Part: {str(part_error)}"
                                )
                                logger.error(
                                    f"DEBUG - Error type: {type(part_error).__name__}"
                                )
                                import traceback

                                logger.error(
                                    f"DEBUG - Stack trace: {traceback.format_exc()}"
                                )
                                raise

                            # Save the file in the ArtifactService
                            version = artifacts_service.save_artifact(
                                app_name=agent_id,
                                user_id=external_id,
                                session_id=adk_session_id,
                                filename=file_data.filename,
                                artifact=file_part,
                            )
                            logger.info(
                                f"Saved file {file_data.filename} as version {version}"
                            )

                            # Add the Part to the list of parts for the message content
                            file_parts.append(file_part)
                        except Exception as e:
                            logger.error(
                                f"Error processing file {file_data.filename}: {str(e)}"
                            )

                # Create the content with the text message and the files
                parts = [Part(text=message)]
                if file_parts:
                    parts.extend(file_parts)

                content = Content(role="user", parts=parts)

                # 执行流式响应，并解析每个 chunk 为 type "a2ui" 或 "text"
                events_async = agent_runner.run_async(
                    user_id=external_id,
                    session_id=adk_session_id,
                    new_message=content,
                )

                async for event in events_async:
                    if event.content and event.content.parts and event.content.parts[0].text:
                        chunk_text = event.content.parts[0].text
                        try:
                            parsed = json.loads(chunk_text)
                            if parsed.get("type") == "a2ui" and "content" in parsed:
                                yield json.dumps(parsed)
                            else:
                                yield json.dumps({"type": "text", "content": chunk_text})
                        except json.JSONDecodeError:
                            yield json.dumps({"type": "text", "content": chunk_text})

            except Exception as e:
                logger.error(f"Error in streaming: {str(e)}")
                yield json.dumps({"type": "text", "content": f"Error: {str(e)"}})

            finally:
                if exit_stack:
                    await exit_stack.aclose()

    except Exception as e:
        logger.error(f"Stream error: {str(e)}")
src/api/chat_routes.py (完整代码 - 处理 A2UI 响应，返回 dict)Python"""
┌──────────────────────────────────────────────────────────────────────────────┐
│ @author: Davidson Gomes                                                      │
│ @file: chat_routes.py                                                        │
│ Developed by: Davidson Gomes                                                 │
│ Creation date: May 13, 2025                                                  │
│ Contact: contato@evolution-api.com                                           │
├──────────────────────────────────────────────────────────────────────────────┤
│ @copyright © Evolution API 2025. All rights reserved.                        │
│ Licensed under the Apache License, Version 2.0                               │
│                                                                              │
│ You may not use this file except in compliance with the License.             │
│ You may obtain a copy of the License at                                      │
│                                                                              │
│    http://www.apache.org/licenses/LICENSE-2.0                                │
│                                                                              │
│ Unless required by applicable law or agreed to in writing, software          │
│ distributed under the License is distributed on an "AS IS" BASIS,            │
│ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.     │
│ See the License for the specific language governing permissions and          │
│ limitations under the License.                                               │
├──────────────────────────────────────────────────────────────────────────────┤
│ @important                                                                   │
│ For any future changes to the code in this file, it is recommended to        │
│ include, together with the modification, the information of the developer    │
│ who changed it and the date of modification.                                 │
└──────────────────────────────────────────────────────────────────────────────┘
"""

import uuid
import base64
from fastapi import (
    APIRouter,
    Depends,
    HTTPException,
    status,
    WebSocket,
    WebSocketDisconnect,
    Header,
)
from sqlalchemy.orm import Session
from src.config.settings import settings
from src.config.database import get_db
from src.core.jwt_middleware import (
    get_jwt_token,
    verify_user_client,
    get_jwt_token_ws,
)
from src.services import (
    agent_service,
)
from src.schemas.chat import ChatRequest, ChatResponse, ErrorResponse, FileData
from src.services.adk.agent_runner import run_agent as run_agent_adk, run_agent_stream
from src.services.crewai.agent_runner import run_agent as run_agent_crewai
from src.core.exceptions import AgentNotFoundError
from src.services.service_providers import (
    session_service,
    artifacts_service,
    memory_service,
)

from datetime import datetime
import logging
import json
from typing import Optional, Dict, List, Any

logger = logging.getLogger(__name__)

router = APIRouter(
    prefix="/chat",
    tags=["chat"],
    responses={404: {"description": "Not found"}},
)

async def get_agent_by_api_key(
    agent_id: str,
    api_key: Optional[str] = Header(None, alias="x-api-key"),
    authorization: Optional[str] = Header(None),
    db: Session = Depends(get_db),
):
    """Flexible authentication for chat routes, allowing JWT or API key"""
    if authorization:
        # Try to authenticate with JWT token first
        try:
            # Extract token from Authorization header if needed
            token = (
                authorization.replace("Bearer ", "")
                if authorization.startswith("Bearer ")
                else authorization
            )
            payload = await get_jwt_token(token)
            agent = agent_service.get_agent(db, agent_id)
            if not agent:
                raise HTTPException(
                    status_code=status.HTTP_404_NOT_FOUND,
                    detail="Agent not found",
                )

            # Verify if the user has access to the agent's client
            await verify_user_client(payload, db, agent.client_id)
            return agent
        except Exception as e:
            logger.warning(f"JWT authentication failed: {str(e)}")
            # If JWT fails, continue to try with API key

    # Try to authenticate with API key
    if not api_key:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Authentication required (JWT or API key)",
        )

    agent = agent_service.get_agent(db, agent_id)
    if not agent or not agent.config:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND, detail="Agent not found"
        )

    # Verify if the API key matches
    if not agent.config.get("api_key") or agent.config.get("api_key") != api_key:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED, detail="Invalid API key"
        )

    return agent

@router.websocket("/ws/{agent_id}/{external_id}")
async def websocket_chat(
    websocket: WebSocket,
    agent_id: str,
    external_id: str,
    db: Session = Depends(get_db),
):
    try:
        # Accept the connection
        await websocket.accept()
        logger.info("WebSocket connection accepted, waiting for authentication")

        # Wait for authentication message
        try:
            auth_data = await websocket.receive_json()
            logger.info(f"Authentication data received: {auth_data}")

            if not (
                auth_data.get("type") == "authorization"
                and (auth_data.get("token") or auth_data.get("api_key"))
            ):
                logger.warning("Invalid authentication message")
                await websocket.close(code=status.WS_1008_POLICY_VIOLATION)
                return

            # Verify if the agent exists
            agent = agent_service.get_agent(db, agent_id)
            if not agent:
                logger.warning(f"Agent {agent_id} not found")
                await websocket.close(code=status.WS_1008_POLICY_VIOLATION)
                return

            # Verify authentication
            is_authenticated = False

            # Try with JWT token
            if auth_data.get("token"):
                try:
                    payload = await get_jwt_token_ws(auth_data["token"])
                    if payload:
                        # Verify if the user has access to the agent
                        await verify_user_client(payload, db, agent.client_id)
                        is_authenticated = True
                except Exception as e:
                    logger.warning(f"JWT authentication failed: {str(e)}")

            # If JWT fails, try with API key
            if not is_authenticated and auth_data.get("api_key"):
                if agent.config and agent.config.get("api_key") == auth_data.get(
                    "api_key"
                ):
                    is_authenticated = True
                else:
                    logger.warning("Invalid API key")

            if not is_authenticated:
                await websocket.close(code=status.WS_1008_POLICY_VIOLATION)
                return

            logger.info(
                f"WebSocket connection established for agent {agent_id} and external_id {external_id}"
            )

            while True:
                try:
                    data = await websocket.receive_json()
                    logger.info(f"Received message: {data}")
                    message = data.get("message")

                    if not message:
                        continue

                    files = None
                    if data.get("files") and isinstance(data.get("files"), list):
                        try:
                            files = []
                            for file_data in data.get("files"):
                                if (
                                    isinstance(file_data, dict)
                                    and file_data.get("filename")
                                    and file_data.get("content_type")
                                    and file_data.get("data")
                                ):
                                    files.append(
                                        FileData(
                                            filename=file_data.get("filename"),
                                            content_type=file_data.get("content_type"),
                                            data=file_data.get("data"),
                                        )
                                    )
                            logger.info(
                                f"Processed {len(files)} files via WebSocket"
                            )
                        except Exception as e:
                            logger.error(f"Error processing files: {str(e)}")
                            files = None

                    async for chunk in run_agent_stream(
                        agent_id=agent_id,
                        external_id=external_id,
                        message=message,
                        session_service=session_service,
                        artifacts_service=artifacts_service,
                        memory_service=memory_service,
                        db=db,
                        files=files,
                    ):
                        await websocket.send_json(
                            {"message": json.loads(chunk), "turn_complete": False}
                        )

                    # Send signal of complete turn
                    await websocket.send_json({"message": "", "turn_complete": True})

                except WebSocketDisconnect:
                    logger.info("Client disconnected")
                    break
                except json.JSONDecodeError:
                    logger.warning("Invalid JSON message received")
                    continue
                except Exception as e:
                    logger.error(f"Error in WebSocket message handling: {str(e)}")
                    await websocket.close(code=status.WS_1011_INTERNAL_ERROR)
                    break

        except WebSocketDisconnect:
            logger.info("Client disconnected during authentication")
        except json.JSONDecodeError:
            logger.warning("Invalid authentication message format")
            await websocket.close(code=status.WS_1008_POLICY_VIOLATION)
        except Exception as e:
            logger.error(f"Error during authentication: {str(e)}")
            await websocket.close(code=status.WS_1011_INTERNAL_ERROR)

    except Exception as e:
        logger.error(f"WebSocket error: {str(e)}")
        await websocket.close(code=status.WS_1011_INTERNAL_ERROR)

@router.post(
    "/{agent_id}/{external_id}",
    response_model=Dict[str, Any],
    responses={
        400: {"model": ErrorResponse},
        404: {"model": ErrorResponse},
        500: {"model": ErrorResponse},
    },
)
async def chat(
    request: ChatRequest,
    agent_id: str,
    external_id: str,
    _=Depends(get_agent_by_api_key),
    db: Session = Depends(get_db),
):
    try:
        if settings.AI_ENGINE == "adk":
            final_response = await run_agent_adk(
                agent_id,
                external_id,
                request.message,
                session_service,
                artifacts_service,
                memory_service,
                db,
                files=request.files,
            )
        elif settings.AI_ENGINE == "crewai":
            final_response = await run_agent_crewai(
                agent_id,
                external_id,
                request.message,
                session_service,
                db,
                files=request.files,
            )

        return {
            "response": final_response["final_response"],  # {"type": "text" | "a2ui", "content": ...}
            "message_history": final_response["message_history"],
            "status": "success",
            "timestamp": datetime.now().isoformat(),
        }

    except AgentNotFoundError as e:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(e)) from e
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=str(e)
        ) from e

前端修改 (Next.js/TypeScript)

frontend/components/A2UIRenderer.tsx (新文件 - A2UI 渲染器，使用 shadcn/ui)tsx'use client'

import React, { useState } from 'react'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { Label } from '@/components/ui/label'
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'

// A2UI 组件映射，参考 A2UI contact_lookup 示例（card with text, button for lookup）
const componentRegistry: Record<string, React.FC<any>> = {
  text: ({ content, style = {} }) => <p className="text-sm text-muted-foreground" style={style}>{content}</p>,

  button: ({ label, action, style = {}, disabled = false, onAction }) => (
    <Button
      variant="default"
      disabled={disabled}
      style={style}
      onClick={() => {
        if (action?.type === 'callback' && action.handler) {
          onAction?.(action.handler, action.data)  // 发送回调到后端
        }
      }}
    >
      {label}
    </Button>
  ),

  card: ({ title, content = [], style = {} }) => (
    <Card style={style}>
      {title && <CardHeader><CardTitle>{title}</CardTitle></CardHeader>}
      <CardContent className="space-y-4">
        {content.map((child: any, i: number) => (
          <A2UIRenderer key={child.id || i} component={child} />
        ))}
      </CardContent>
    </Card>
  ),

  form: ({ fields = [], actions = [], style = {} }) => {
    const [formData, setFormData] = useState<Record<string, string>>({})

    return (
      <form style={style} className="space-y-4" onSubmit={(e) => e.preventDefault()}>
        {fields.map((field: any) => (
          <A2UIRenderer
            key={field.id}
            component={{
              ...field,
              value: formData[field.id] || '',
              onChange: (val: string) => setFormData(prev => ({ ...prev, [field.id]: val }))
            }}
          />
        ))}
        <div className="flex gap-2">
          {actions.map((action: any) => (
            <A2UIRenderer key={action.id} component={action} onAction={(handler: string, data: any) => {
              // 提交表单
              onAction(handler, formData)
            }} />
          ))}
        </div>
      </form>
    )
  },

  'text-field': ({ label, placeholder, required, value, onChange, style = {} }) => (
    <div className="space-y-1">
      {label && <Label>{label}{required ? '*' : ''}</Label>}
      <Input
        type="text"
        placeholder={placeholder}
        required={required}
        value={value}
        onChange={(e) => onChange?.(e.target.value)}
        style={style}
      />
    </div>
  ),
  // 扩展更多组件基于 A2UI 示例
}

interface A2UIRendererProps {
  component: any
  onAction?: (handler: string, data?: any) => void
}

const A2UIRenderer: React.FC<A2UIRendererProps> = ({ component, onAction }) => {
  const { type, id, ...props } = component
  const Component = componentRegistry[type]
  if (!Component) return <div className="text-red-500">未知组件: {type}</div>
  return <Component {...props} onAction={onAction} />
}

export default A2UIRenderer
frontend/app/chat/layout.tsx (新/修改 - 聊天布局，flex 两列)tsximport React from 'react'

export default function ChatLayout({ children }: { children: React.ReactNode }) {
  return (
    <div className="flex h-screen bg-background">
      {children}
    </div>
  )
}
frontend/app/chat/[agentId]/[externalId]/page.tsx (完整代码 - 聊天页面，左聊天右 A2UI)tsx'use client'

import React, { useState } from 'react'
import { useParams } from 'next/navigation'
import A2UIRenderer from '@/components/A2UIRenderer'
import { Input } from '@/components/ui/input'
import { Button } from '@/components/ui/button'
import { ScrollArea } from '@/components/ui/scroll-area'

interface Message {
  role: 'user' | 'assistant'
  type?: 'text' | 'a2ui'
  content: string | { components: any[] }
}

const ChatPage = () => {
  const params = useParams()
  const agentId = params.agentId as string
  const externalId = params.externalId as string

  const [messages, setMessages] = useState<Message[]>([])
  const [input, setInput] = useState('')
  const [a2uiPanel, setA2uiPanel] = useState<any>(null)  // 右侧 A2UI

  const sendMessage = async (message: string, callbackData?: any) => {
    if (!message) return

    setMessages(prev => [...prev, { role: 'user', content: message }])

    try {
      const body = { message }
      if (callbackData) {
        body['callback_data'] = callbackData  // 如果有表单数据
      }
      const res = await fetch(`/api/chat/${agentId}/${externalId}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(body),
      })
      const data = await res.json()
      const response = data.response

      setMessages(prev => [...prev, { role: 'assistant', ...response }])

      // 如果返回 A2UI，展开右侧面板
      if (response.type === 'a2ui' && response.content?.components) {
        setA2uiPanel(response.content)
      } else {
        setA2uiPanel(null)  // 如果不是 A2UI，隐藏面板
      }
    } catch (error) {
      console.error('Error:', error)
    }
    setInput('')
  }

  const handleA2uiAction = (handler: string, data?: any) => {
    const callbackMessage = `A2UI callback: ${handler}`
    sendMessage(callbackMessage, data)
  }

  return (
    <>
      {/* 左侧聊天 */}
      <div className="w-1/2 border-r p-4 flex flex-col">
        <ScrollArea className="flex-1 mb-4">
          {messages.map((msg, idx) => (
            <div
              key={idx}
              className={`mb-4 ${msg.role === 'user' ? 'text-right' : 'text-left'}`}
            >
              <div
                className={`inline-block p-3 rounded-lg ${msg.role === 'user' ? 'bg-primary text-primary-foreground' : 'bg-muted'}`}
              >
                {msg.type === 'a2ui' ? (
                  <p className="text-sm italic">A2UI 已显示在右侧</p>
                ) : (
                  <p>{String(msg.content)}</p>
                )}
              </div>
            </div>
          ))}
        </ScrollArea>
        <div className="flex gap-2">
          <Input
            value={input}
            onChange={(e) => setInput(e.target.value)}
            placeholder="输入消息..."
            onKeyDown={(e) => e.key === 'Enter' && sendMessage(input)}
          />
          <Button onClick={() => sendMessage(input)}>发送</Button>
        </div>
      </div>

      {/* 右侧 A2UI 面板（动态展开） */}
      <div className={`w-1/2 p-4 flex flex-col transition-all duration-300 ${a2uiPanel ? 'block' : 'hidden w-0'}`}>
        <h2 className="text-lg font-semibold mb-4">A2UI 交互面板</h2>
        <ScrollArea className="flex-1 border rounded-lg p-4 bg-card">
          {a2uiPanel && a2uiPanel.components.map((comp: any, i: number) => (
            <A2UIRenderer key={comp.id || i} component={comp} onAction={handleA2uiAction} />
          ))}
        </ScrollArea>
      </div>
    </>
  )
}

export default ChatPage

这些是所有修改的完整代码。应用后，运行项目测试 A2UI 响应（e.g., 输入 "show contact lookup UI"，参考 A2UI 示例）。如果文件路径不对，调整到仓库结构。
