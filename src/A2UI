我现在基于GitHub 一个开源项目Evo Ai，https://github.com/EvolutionAPI/evo-ai开发聊天机器人，仅使用其中的adk模块，在这个基础上我如何将agentskills和google的A2UI项目整合到我的聊天机器人里去整合 AgentSkills 和 Google's A2UI 到基于 Evo AI ADK 的聊天机器人
基于 Evo AI 项目（https://github.com/EvolutionAPI/evo-ai），你只使用 ADK 模块来开发聊天机器人。ADK 是 Evo AI 的核心 AI 引擎框架，用于创建、配置和执行代理（agents），支持工具集成、LLM 调用和工作流。AgentSkills 是一个开放标准，用于打包可重用技能（instructions、scripts 和 resources），以扩展 AI 代理的能力。Google's A2UI 是一个协议，用于让代理生成声明式 UI（JSON 格式），前端可以安全渲染成交互界面，而不执行任意代码。
以下是逐步指导，帮助你将两者整合到你的聊天机器人中。假设你已经设置了 Evo AI 的后端（FastAPI）和前端（Next.js），并启用 ADK（在 .env 中设置 AI_ENGINE=adk）。整合需要修改后端代码（src/ 目录下的代理逻辑）和前端（以渲染 A2UI）。如果你是初学者，建议先 fork Evo AI 仓库，并在本地运行 docker-compose up 来测试。
1. 准备环境和依赖

克隆和设置 Evo AI：
git clone https://github.com/EvolutionAPI/evo-ai
cd evo-ai
复制 .env.example 到 .env，配置数据库（PostgreSQL）、Redis 和 LLM API 密钥（e.g., OpenAI 或 Claude）。
docker-compose up -d 启动后端、前端和数据库。

添加依赖：
对于 AgentSkills：无需额外 pip 安装，因为它是文件系统基于的标准。但如果你使用 Claude 或兼容的 LLM，确保后端集成支持文件工具（e.g., 通过 LangChain 或直接 shell 命令）。
对于 A2UI：安装 A2UI 的客户端库。
前端（Next.js）：npm install @google/a2ui-web-components（用于 Web 渲染器）。
如果你的聊天机器人有移动端（如 Flutter），使用 flutter pub add gen_ui_sdk（它内置 A2UI 支持）。

如果需要 LLM 生成 A2UI JSON，集成兼容的模型（如 Gemini 或 Claude），因为 A2UI 设计用于生成式 UI。


2. 整合 AgentSkills
AgentSkills 允许你的 ADK 代理加载特定任务的“技能包”（一个文件夹，包含 SKILL.md 文件和其他资源）。这可以扩展你的聊天机器人，使其处理领域特定任务（如数据分析或自定义工作流），而非通用响应。

步骤 A: 创建 AgentSkills 文件夹
在 Evo AI 后端项目中，创建 skills/ 目录（e.g., src/skills/）。
对于每个技能，创建一个子文件夹，例如 src/skills/data-analysis/。
在子文件夹中添加 SKILL.md 文件（YAML 前置 + Markdown 指令）：text---
name: Data Analysis Skill
description: Analyzes CSV data and generates insights.
---
# Instructions
1. Use pandas to load CSV: import pandas as pd; df = pd.read_csv('data.csv')
2. Compute stats: df.describe()
3. If user asks for plot, use matplotlib.
可选：添加脚本（e.g., analyze.py）或模板（e.g., report_template.md）。

步骤 B: 在 ADK 代理中加载 AgentSkills
修改 Evo AI 的 ADK 配置（src/adk/ 或 src/agents/ 目录）。
在代理初始化时，扫描 skills/ 目录并加载元数据（name 和 description）到系统提示中。这让 LLM 知道何时调用技能。
示例代码修改（在 src/adk/agent.py 或类似文件中添加）：Pythonimport os
import yaml

def load_skills(skills_dir='src/skills'):
    skills = []
    for skill_folder in os.listdir(skills_dir):
        skill_path = os.path.join(skills_dir, skill_folder, 'SKILL.md')
        if os.path.exists(skill_path):
            with open(skill_path, 'r') as f:
                content = f.read()
                frontmatter = yaml.safe_load(content.split('---')[1])
                skills.append({
                    'name': frontmatter['name'],
                    'description': frontmatter['description'],
                    'path': skill_path
                })
    return skills

# 在代理系统提示中添加
system_prompt = "You have access to skills: " + "\n".join([f"{s['name']}: {s['description']}" for s in load_skills()])
# 当 LLM 决定使用技能时，调用工具读取完整 SKILL.md
def use_skill(tool_input):
    skill_path = tool_input['path']
    with open(skill_path, 'r') as f:
        return f.read()  # 返回指令给 LLM
在 Evo AI 的代理配置中（UI 或 API），将这个作为自定义工具附加到你的 ADK 代理（e.g., Task Agent 或 LLM Agent）。
测试：在聊天界面输入 “Analyze this data: [CSV link]”，代理应加载技能并执行。

潜在挑战：
如果你的机器人使用 Claude，确保启用文件工具支持（Claude 支持 AgentSkills 原生）。
对于复杂技能，集成 LangGraph（Evo AI 已内置）来处理多步工作流。


3. 整合 Google's A2UI
A2UI 让你的 ADK 代理生成动态 UI（如表单、卡片或仪表盘），而非纯文本响应。这适合聊天机器人场景，例如生成交互式表单或可视化结果。前端会渲染 A2UI JSON 为 native UI。

步骤 A: 在 ADK 后端生成 A2UI JSON
修改代理响应逻辑（src/adk/runtime.py 或代理执行函数），让 LLM 生成 A2UI 格式的 JSON 而非纯文本。
使用提示工程指导 LLM：Pythona2ui_prompt = """
Generate UI in A2UI format (JSON). Use components like 'text', 'button', 'card'.
Example: {"components": [{"type": "text", "content": "Hello"}, {"type": "button", "label": "Click", "action": "submit"}]}
"""
# 在代理调用 LLM 时附加这个提示
response = llm.invoke(user_input + a2ui_prompt)
# 解析响应为 A2UI JSON
a2ui_json = extract_json_from_response(response)
通过 Evo AI 的 REST API（/agents/{id}/chat）返回这个 JSON，作为响应的一部分。

步骤 B: 在前端渲染 A2UI
Evo AI 前端使用 Next.js 和 ReactFlow。修改聊天组件（e.g., components/Chat.tsx）以处理 A2UI JSON。
集成 A2UI 渲染器：JavaScript// npm install @google/a2ui-lit (或类似 Web Components 渲染器)
import { A2UIRenderer } from '@google/a2ui-web-components';

function ChatMessage({ message }) {
  if (message.type === 'a2ui') {
    return <A2UIRenderer json={message.content} />;
  }
  return <p>{message.text}</p>;
}
对于交互：A2UI 支持动作（e.g., button click 发送事件回后端）。在渲染器中处理回调，将用户输入发回 ADK 代理。
如果你的机器人有 Flutter 移动端，使用 GenUI SDK：Dartimport 'package:gen_ui_sdk/gen_ui_sdk.dart';

GenUIRenderer(json: a2uiJson);  // 渲染到 Flutter UI

潜在挑战：
确保 LLM 可靠生成有效 A2UI JSON（使用结构化输出，如 JSON mode）。
安全：A2UI 默认安全（无代码执行），但自定义组件需注册在渲染器中。
测试：运行 Evo AI 前端，输入 “Show me a form for booking”，代理应返回 A2UI JSON 并渲染交互 UI。


4. 测试和扩展

端到端测试：在 Evo AI UI 创建一个 ADK Task Agent，附加技能和 A2UI 逻辑。使用聊天界面测试整合（e.g., “Use data analysis skill and show results in UI”）。
扩展：
结合两者：让 AgentSkills 生成数据，然后用 A2UI 可视化（e.g., 技能计算 stats，A2UI 生成 chart 组件）。
监控：使用 Evo AI 的 Langfuse 集成追踪提示和工具调用。
部署：更新 Docker 镜像，推送自定义版本。

资源：
AgentSkills 文档：https://agentskills.io
A2UI 仓库：https://github.com/google/A2UI（包含示例和渲染器）
Evo AI 扩展：查看 src/ 下的工具注册，参考 LangGraph 工作流。


如果遇到具体代码错误，提供更多细节（如错误日志），我可以进一步细化。40 sources帮我详细解释如何整合A2UI，并给出更详细的代码详细解释如何整合 Google's A2UI 到基于 Evo AI ADK 的聊天机器人
A2UI (Agent-to-User Interface) 是 Google 开发的一个开源协议，用于让 AI 代理生成声明式 UI（以 JSON 格式描述），客户端可以安全渲染成交互界面，而不会执行任意代码。这非常适合你的聊天机器人场景，例如生成动态表单、卡片或按钮，让用户交互更丰富，而不是纯文本响应。A2UI 的设计是框架无关的（framework-agnostic），JSON 可以跨平台渲染（如 Web、Flutter），强调安全性（只渲染预批准的组件）和增量更新（逐步更新 UI）。
基于 Evo AI 项目（https://github.com/EvolutionAPI/evo-ai），你只使用 ADK 模块（AI 引擎框架，用于代理配置和执行）。整合 A2UI 需要修改后端（FastAPI，生成 JSON）和前端（Next.js，渲染 UI）。假设你已 fork 仓库，并在本地运行（docker-compose up）。如果没有，建议先设置环境，包括配置 LLM（如 OpenAI 或 Gemini，在 .env 中）。
整合的核心思路：

后端：让 ADK 代理的 LLM 生成 A2UI JSON，而不是纯文本。使用提示工程指导 LLM 输出结构化 JSON。
前端：解析 JSON 并渲染成 React 组件。
交互：用户点击 UI 元素时，前端发送事件回后端，代理处理并返回更新 JSON。

下面是详细步骤和代码。代码基于 Evo AI 的结构（src/ 目录下）和 A2UI 的规范（v0.8 公共预览版）。我使用了工具获取的最新 A2UI 示例，确保准确。
1. 准备工作

依赖安装：
后端：无需额外 pip（Evo AI 已内置 LangChain 和 LLM 支持）。如果使用 Gemini，确保 .env 中配置 GOOGLE_API_KEY。
前端：cd frontend && npm install @lit/react（用于 A2UI 渲染器适配 React/Next.js）。A2UI 官方有 Lit 渲染器，你可以适配到 React。

A2UI 组件目录：A2UI 支持组件如 text、button、card、form。完整列表见 A2UI 仓库的 specification/ 目录。
测试 LLM：确保你的 ADK 代理使用支持结构化输出的 LLM（如 GPT-4 或 Gemini），以生成有效 JSON。

2. 后端整合：让 ADK 代理生成 A2UI JSON
在 Evo AI 的 ADK 中，代理执行在 src/adk/ 或 src/agents/ 目录下。关键是修改代理的系统提示和响应处理逻辑，让 LLM 输出 A2UI JSON。

步骤：
在代理初始化时，添加 A2UI 提示，指导 LLM 何时生成 UI（例如，当用户请求表单或可视化时）。
在聊天 API（/agents/{id}/chat）中，解析 LLM 输出为 JSON，并返回给前端。
处理交互：如果 UI 有 action（如 button click），前端发送回调，后端代理处理并返回更新 JSON。

详细代码修改：
修改 src/adk/agent.py（或类似代理核心文件）。添加 A2UI 生成逻辑。Python# src/adk/agent.py（假设这是代理执行文件；如果不是，查找类似 llm.invoke 的地方）
import json
from langchain.prompts import PromptTemplate
from langchain.llms import OpenAI  # 或你的 LLM，如 from langchain_google_genai import ChatGoogleGenerativeAI

# 定义 A2UI 提示模板（指导 LLM 生成 JSON）
A2UI_PROMPT_TEMPLATE = """
You are an AI agent that can generate interactive UI using A2UI protocol.
If the user query requires a visual or interactive response (e.g., form, card, button), output in A2UI JSON format.
A2UI JSON is a list of components with id, type, content/style/action.
Example for a simple form:
{{
  "components": [
    {{"id": "title-1", "type": "text", "content": "Enter Details", "style": {{"fontSize": "18px"}}}},
    {{"id": "input-name", "type": "text-field", "label": "Name", "required": true}},
    {{"id": "btn-submit", "type": "button", "label": "Submit", "action": {{"type": "callback", "handler": "onSubmit"}}}}
  ]
}}

User query: {user_input}
If UI is needed, output ONLY the JSON. Otherwise, respond with text.
"""

class ADKAgent:
    def __init__(self, llm_model="gpt-4"):  # 或 "gemini-pro"
        self.llm = OpenAI(model_name=llm_model)  # 替换为你的 LLM
        self.prompt = PromptTemplate.from_template(A2UI_PROMPT_TEMPLATE)

    def execute(self, user_input):
        # 生成提示
        full_prompt = self.prompt.format(user_input=user_input)
        # 调用 LLM
        response = self.llm(full_prompt)
        
        # 尝试解析为 A2UI JSON
        try:
            a2ui_json = json.loads(response.strip())  # 假设 LLM 输出纯 JSON
            return {"type": "a2ui", "content": a2ui_json}  # 返回给 API
        except json.JSONDecodeError:
            # 如果不是 JSON，返回纯文本
            return {"type": "text", "content": response}

# 在 Evo AI 的 API 路由中集成（src/main.py 或 src/api/routers/agents.py）
from fastapi import APIRouter
router = APIRouter()

@router.post("/agents/{agent_id}/chat")
async def chat_with_agent(agent_id: str, user_input: str):
    agent = ADKAgent()  # 实例化你的代理
    response = agent.execute(user_input)
    return response  # 前端会收到 {"type": "a2ui", "content": {...}} 或文本
解释：
提示模板：使用示例指导 LLM 生成有效 JSON。A2UI JSON 是一个 "components" 数组，每个组件有 id（唯一标识）、type（类型，如 "text"、"button"）、content/style/action。
执行逻辑：LLM 输出如果可解析为 JSON，则标记为 "a2ui" 类型；否则为文本。
增量更新：对于回调（如 "onSubmit"），在前端处理后，发送新输入到 /chat API，代理返回 patch JSON（仅更新部分组件）。
潜在问题：如果 LLM 不严格输出 JSON，使用结构化输出（如 OpenAI 的 JSON mode）：self.llm = OpenAI(..., response_format={"type": "json_object"})。



3. 前端整合：渲染 A2UI JSON
Evo AI 前端是 Next.js（frontend/ 目录）。修改聊天组件以解析 A2UI JSON 并渲染。

步骤：
创建 A2UI 渲染器组件，映射 A2UI 类型到 React 组件。
在聊天界面（如 components/Chat.tsx）中，如果响应是 "a2ui" 类型，渲染 JSON。
处理交互：按钮点击时，发送事件回后端 API。

详细代码修改：
先创建新组件：frontend/components/A2UIRenderer.tsxTypeScript// frontend/components/A2UIRenderer.tsx
import React from 'react';

// 组件映射：将 A2UI 类型映射到 React 组件
const componentMap: { [key: string]: React.FC<any> } = {
  text: ({ content, style }) => <p style={style}>{content}</p>,
  button: ({ label, action, style }) => (
    <button
      style={style}
      onClick={() => {
        // 处理 action：发送回调到后端
        if (action.type === 'callback') {
          fetch('/api/agents/{agent_id}/chat', {  // 替换为你的 API
            method: 'POST',
            body: JSON.stringify({ user_input: `Handle ${action.handler}` }),
          }).then(res => res.json()).then(updateUI);  // 更新 UI
        }
      }}
    >
      {label}
    </button>
  ),
  card: ({ title, content, style }) => (
    <div style={{ ...style, border: '1px solid #ddd', padding: '16px', borderRadius: '8px' }}>
      {title && <h3>{title}</h3>}
      {content.map((c: any) => <A2UIRenderer key={c.id} component={c} />)}
    </div>
  ),
  form: ({ fields, actions, style }) => (
    <form style={style}>
      {fields.map((field: any) => <A2UIRenderer key={field.id} component={field} />)}
      {actions.map((action: any) => <A2UIRenderer key={action.id} component={action} />)}
    </form>
  ),
  'text-field': ({ label, required, style }) => (
    <div>
      <label>{label}{required ? '*' : ''}</label>
      <input type="text" style={style} required={required} />
    </div>
  ),
  // 添加更多组件，如 image, list 等，根据 A2UI 规范
};

interface A2UIRendererProps {
  component: any;
}

const A2UIRenderer: React.FC<A2UIRendererProps> = ({ component }) => {
  const { type, style, ...props } = component;
  const Component = componentMap[type];
  if (!Component) return null;  // 未支持的组件
  return <Component {...props} style={style} />;
};

export default A2UIRenderer;然后，修改聊天组件：frontend/components/Chat.tsx（或类似）TypeScript// frontend/components/Chat.tsx（简化示例）
import React, { useState } from 'react';
import A2UIRenderer from './A2UIRenderer';

const Chat: React.FC = () => {
  const [messages, setMessages] = useState<any[]>([]);

  const sendMessage = async (userInput: string) => {
    // 发送到后端 API
    const res = await fetch('/api/agents/{agent_id}/chat', {  // 替换 agent_id
      method: 'POST',
      body: JSON.stringify({ user_input: userInput }),
    });
    const data = await res.json();
    setMessages([...messages, { role: 'user', content: userInput }, { role: 'bot', ...data }]);
  };

  return (
    <div>
      {messages.map((msg, idx) => (
        <div key={idx}>
          {msg.role === 'bot' && msg.type === 'a2ui' ? (
            msg.content.components.map((comp: any) => (
              <A2UIRenderer key={comp.id} component={comp} />
            ))
          ) : (
            <p>{msg.content}</p>
          )}
        </div>
      ))}
      {/* 输入框和发送按钮 */}
    </div>
  );
};

export default Chat;
解释：
componentMap：映射 A2UI 类型到 React（如 button 绑定 onClick 发送回调）。
递归渲染：如 card 包含子组件，使用 A2UIRenderer 递归。
交互处理：onClick 发送新输入到后端，模拟回调。
Lit 适配：如果想用官方 Lit 渲染器，npm install lit，然后在 React 中用 @lit/react 包裹。



4. A2UI JSON 示例

简单卡片：JSON{
  "components": [
    {"id": "card-1", "type": "card", "title": "天气预报", "content": [{"id": "text-1", "type": "text", "content": "今天晴天，温度 25°C"}]}
  ]
}
交互表单：JSON{
  "components": [
    {"id": "form-1", "type": "form", "fields": [{"id": "input-1", "type": "text-field", "label": "你的名字"}], "actions": [{"id": "btn-1", "type": "button", "label": "提交", "action": {"type": "callback", "handler": "submitName"}}]}
  ]
}

5. 测试和调试

运行：docker-compose up，访问 http://localhost:3000，创建 ADK 代理，聊天输入 “Show me a form for login”。
预期：后端生成 JSON，前端渲染表单。
调试：检查控制台日志，确保 JSON 有效。如果 LLM 输出不准，细化提示。
扩展：添加更多组件支持；对于 AgentSkills 整合（如之前所述），让技能输出数据，然后用 A2UI 可视化。

如果代码运行出错，提供错误详情，我可以进一步调整。A2UI 还在预览阶段，建议检查官方仓库更新。在LLMagent的基础上，将A2UI调用模型生成JSON的逻辑加到LLMagent,然后前端代码从response中拿到结果并使用A2UI展示，请你仔细阅读完整的Evo ai代码后，分析并按照上述要求给出完整的代码分析 Evo AI 代码并整合 A2UI
基于提供的 Evo AI 代码（从 GitHub 仓库提取），我仔细阅读了关键文件，包括 src/main.py、src/api/agent_routes.py、src/services/agent_service.py、src/api/chat_routes.py、src/services/service_providers.py 和 src/services/adk/agent_runner.py、src/services/adk/agent_builder.py。仓库使用 Google Agent Development Kit (ADK) 作为 AI 引擎（通过 .env 中的 AI_ENGINE=adk 配置），LLM Agent 是基本代理类型，使用 LlmAgent 类构建。代理执行通过 Runner 类处理，聊天交互在 chat_routes.py 的 /chat/{agent_id}/{external_id} 端点中调用 run_agent_adk。
分析要点

LLM Agent 结构：在 agent_builder.py 中，build_llm_agent 方法构建 LlmAgent，包括系统提示 (instruction)、工具和子代理。系统提示是从代理的 instruction 字段格式化而来。这里是添加 A2UI 逻辑的最佳位置：通过提示工程指导 LLM 生成 A2UI JSON。
代理执行：在 agent_runner.py 的 run_agent 函数中，收集 LLM 响应作为 final_response_text。需要修改此函数，尝试解析响应为 JSON，如果符合 A2UI 格式，则标记类型为 "a2ui"。
聊天路由：在 chat_routes.py 中，返回 ChatResponse。修改以支持 {"type": "text" | "a2ui", "content": ...}。
前端：仓库中 frontend 目录未公开详细文件列表（可能未完全上传或私有），但从 README 推断为 Next.js App Router 结构，聊天界面很可能在 frontend/src/app/chat/[agent_id]/[external_id]/page.tsx 或类似。假设标准 Chat 组件，我提供修改后的代码，包括 A2UIRenderer。
整合逻辑：
后端：对于 LLM Agent，添加 A2UI 提示模板到系统提示。LLM 输出如果需要 UI，则为 JSON 对象（如 {"components": [...] }）；否则为纯文本。在 agent_runner.py 中解析响应。
前端：从响应中检查 type，如果 "a2ui"，使用 A2UIRenderer 渲染 JSON。
假设：使用 Google LLM (如 Gemini)，支持 JSON 输出。确保提示指导 LLM 使用 JSON mode。
安全：A2UI JSON 安全渲染，无代码执行。


以下是修改后的完整代码文件。只有必要修改的文件提供完整内容；其他文件保持原样，但提及变更点。
1. 修改 src/services/adk/agent_builder.py（添加 A2UI 提示到 LLM Agent）
在 _create_llm_agent 方法中，附加 A2UI 提示到 formatted_prompt。
Python"""
┌──────────────────────────────────────────────────────────────────────────────┐
│ @author: Davidson Gomes                                                      │
│ @file: agent_builder.py                                                      │
│ Developed by: Davidson Gomes                                                 │
│ Creation date: May 13, 2025                                                  │
│ Contact: contato@evolution-api.com                                           │
├──────────────────────────────────────────────────────────────────────────────┤
│ @copyright © Evolution API 2025. All rights reserved.                        │
│ Licensed under the Apache License, Version 2.0                               │
│                                                                              │
│ You may not use this file except in compliance with the License.             │
│ You may obtain a copy of the License at                                      │
│                                                                              │
│    http://www.apache.org/licenses/LICENSE-2.0                                │
│                                                                              │
│ Unless required by applicable law or agreed to in writing, software          │
│ distributed under the License is distributed on an "AS IS" BASIS,            │
│ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.     │
│ See the License for the specific language governing permissions and          │
│ limitations under the License.                                               │
├──────────────────────────────────────────────────────────────────────────────┤
│ @important                                                                   │
│ For any future changes to the code in this file, it is recommended to        │
│ include, together with the modification, the information of the developer    │
│ who changed it and the date of modification.                                 │
└──────────────────────────────────────────────────────────────────────────────┘
"""

from typing import List, Optional, Tuple
from google.adk.agents.llm_agent import LlmAgent
from google.adk.agents import SequentialAgent, ParallelAgent, LoopAgent, BaseAgent
from google.adk.models.lite_llm import LiteLlm
from google.adk.tools.agent_tool import AgentTool
from src.schemas.schemas import Agent
from src.utils.logger import setup_logger
from src.core.exceptions import AgentNotFoundError
from src.services.agent_service import get_agent
from src.services.adk.custom_tools import CustomToolBuilder
from src.services.adk.mcp_service import MCPService
from src.services.adk.custom_agents.a2a_agent import A2ACustomAgent
from src.services.adk.custom_agents.workflow_agent import WorkflowAgent
from src.services.adk.custom_agents.task_agent import TaskAgent
from src.services.apikey_service import get_decrypted_api_key
from sqlalchemy.orm import Session
from contextlib import AsyncExitStack
from google.adk.tools import load_memory

from datetime import datetime
import uuid

from src.schemas.agent_config import AgentTask

logger = setup_logger(__name__)

# A2UI 提示模板（指导 LLM 生成 JSON UI）
A2UI_PROMPT = """
You can generate interactive UI using A2UI protocol if the query requires visual or interactive response (e.g., forms, cards, buttons).
Output ONLY in JSON format if UI is needed: {"type": "a2ui", "content": {"components": [{"id": "example", "type": "text", "content": "Hello"}]}}.
Example components: text, button (with action {"type": "callback", "handler": "onClick"}), card, form, text-field.
If no UI needed, output plain text with {"type": "text", "content": "response"}.
Use JSON mode for structured output.
"""

class AgentBuilder:
    def __init__(self, db: Session):
        self.db = db
        self.custom_tool_builder = CustomToolBuilder()
        self.mcp_service = MCPService()

    async def _agent_tools_builder(self, agent) -> List[AgentTool]:
        """Build the tools for an agent."""
        agent_tools_ids = agent.config.get("agent_tools")
        agent_tools = []
        if agent_tools_ids and isinstance(agent_tools_ids, list):
            for agent_tool_id in agent_tools_ids:
                sub_agent = get_agent(self.db, agent_tool_id)
                llm_agent, _ = await self.build_llm_agent(sub_agent)
                if llm_agent:
                    agent_tools.append(AgentTool(agent=llm_agent))
        return agent_tools

    async def _create_llm_agent(
        self, agent, enabled_tools: List[str] = []
    ) -> Tuple[LlmAgent, Optional[AsyncExitStack]]:
        """Create an LLM agent from the agent data."""
        # Get custom tools from the configuration
        custom_tools = []
        custom_tools = self.custom_tool_builder.build_tools(agent.config)

        # Get MCP tools from the configuration
        mcp_tools = []
        mcp_exit_stack = None
        if agent.config.get("mcp_servers") or agent.config.get("custom_mcp_servers"):
            mcp_tools, mcp_exit_stack = await self.mcp_service.build_tools(
                agent.config, self.db
            )

        # Get agent tools
        agent_tools = await self._agent_tools_builder(agent)

        # Combine all tools
        all_tools = custom_tools + mcp_tools + agent_tools

        if enabled_tools:
            all_tools = [tool for tool in all_tools if tool.name in enabled_tools]
            logger.info(f"Enabled tools enabled. Total tools: {len(all_tools)}")

        now = datetime.now()
        current_datetime = now.strftime("%d/%m/%Y %H:%M")
        current_day_of_week = now.strftime("%A")
        current_date_iso = now.strftime("%Y-%m-%d")
        current_time = now.strftime("%H:%M")

        # Substitute variables in the prompt
        formatted_prompt = agent.instruction.format(
            current_datetime=current_datetime,
            current_day_of_week=current_day_of_week,
            current_date_iso=current_date_iso,
            current_time=current_time,
        )

        # add role on beginning of the prompt
        if agent.role:
            formatted_prompt = (
                f"{agent.role}\n\n{formatted_prompt}"
            )

        # add goal on beginning of the prompt
        if agent.goal:
            formatted_prompt = (
                f"{agent.goal}\n\n{formatted_prompt}"
            )

        # Check if load_memory is enabled
        if agent.config.get("load_memory"):
            all_tools.append(load_memory)
            formatted_prompt = (
                formatted_prompt
                + "\n\nYou have access to load_memory tool to load previous conversation memory.\n\n"
            )

        # 添加 A2UI 提示到系统提示末尾
        formatted_prompt += A2UI_PROMPT

        # Get API key from api_key_id
        api_key = None

        # Get API key from api_key_id
        if hasattr(agent, "api_key_id") and agent.api_key_id:
            decrypted_key = get_decrypted_api_key(self.db, agent.api_key_id)
            if decrypted_key:
                logger.info(f"Using stored API key for agent {agent.name}")
                api_key = decrypted_key
            else:
                logger.error(f"Stored API key not found for agent {agent.name}")
                raise ValueError(
                    f"API key with ID {agent.api_key_id} not found or inactive"
                )
        else:
            # Check if there is an API key in the config (temporary field)
            config_api_key = agent.config.get("api_key") if agent.config else None
            if config_api_key:
                logger.info(f"Using config API key for agent {agent.name}")
                # Check if it is a UUID of a stored key
                try:
                    key_id = uuid.UUID(config_api_key)
                    decrypted_key = get_decrypted_api_key(self.db, key_id)
                    if decrypted_key:
                        logger.info("Config API key is a valid reference")
                        api_key = decrypted_key
                    else:
                        # Use the key directly
                        api_key = config_api_key
                except (ValueError, TypeError):
                    # It is not a UUID, use directly
                    api_key = config_api_key
            else:
                logger.error(f"No API key configured for agent {agent.name}")
                raise ValueError(
                    f"Agent {agent.name} does not have a configured API key"
                )

        return (
            LlmAgent(
                name=agent.name,
                model=LiteLlm(model=agent.model, api_key=api_key),
                instruction=formatted_prompt,
                description=agent.description,
                tools=all_tools,
            ),
            mcp_exit_stack,
        )

    async def _get_sub_agents(
        self, sub_agent_ids: List[str]
    ) -> List[Tuple[LlmAgent, Optional[AsyncExitStack]]]:
        """Get and create LLM sub-agents."""
        sub_agents = []
        for sub_agent_id in sub_agent_ids:
            sub_agent_id_str = str(sub_agent_id)

            agent = get_agent(self.db, sub_agent_id_str)

            if agent is None:
                logger.error(f"Sub-agent not found: {sub_agent_id_str}")
                raise AgentNotFoundError(f"Agent with ID {sub_agent_id_str} not found")

            logger.info(f"Sub-agent found: {agent.name} (type: {agent.type})")

            if agent.type == "llm":
                sub_agent, exit_stack = await self._create_llm_agent(agent)
            elif agent.type == "a2a":
                sub_agent, exit_stack = await self.build_a2a_agent(agent)
            elif agent.type == "workflow":
                sub_agent, exit_stack = await self.build_workflow_agent(agent)
            elif agent.type == "task":
                sub_agent, exit_stack = await self.build_task_agent(agent)
            elif agent.type == "sequential":
                sub_agent, exit_stack = await self.build_composite_agent(agent)
            elif agent.type == "parallel":
                sub_agent, exit_stack = await self.build_composite_agent(agent)
            elif agent.type == "loop":
                sub_agent, exit_stack = await self.build_composite_agent(agent)
            else:
                raise ValueError(f"Invalid agent type: {agent.type}")

            sub_agents.append(sub_agent)
            logger.info(f"Sub-agent added: {agent.name}")

        logger.info(f"Sub-agents created: {len(sub_agents)}")
        logger.info(f"Sub-agents: {str(sub_agents)}")

        return sub_agents

    async def build_llm_agent(
        self, root_agent, enabled_tools: List[str] = []
    ) -> Tuple[LlmAgent, Optional[AsyncExitStack]]:
        """Build an LLM agent with its sub-agents."""
        logger.info("Creating LLM agent")

        sub_agents = []
        if root_agent.config.get("sub_agents"):
            sub_agents_with_stacks = await self._get_sub_agents(
                root_agent.config.get("sub_agents")
            )
            sub_agents = [agent for agent, _ in sub_agents_with_stacks]

        root_llm_agent, exit_stack = await self._create_llm_agent(
            root_agent, enabled_tools
        )
        if sub_agents:
            root_llm_agent.sub_agents = sub_agents

        return root_llm_agent, exit_stack

    async def build_a2a_agent(
        self, root_agent
    ) -> Tuple[BaseAgent, Optional[AsyncExitStack]]:
        """Build an A2A agent with its sub-agents."""
        logger.info(f"Creating A2A agent from {root_agent.agent_card_url}")

        if not root_agent.agent_card_url:
            raise ValueError("agent_card_url is required for a2a agents")

        try:
            sub_agents = []
            if root_agent.config.get("sub_agents"):
                sub_agents_with_stacks = await self._get_sub_agents(
                    root_agent.config.get("sub_agents")
                )
                sub_agents = [agent for agent, _ in sub_agents_with_stacks]

            config = root_agent.config or {}
            timeout = config.get("timeout", 300)

            a2a_agent = A2ACustomAgent(
                name=root_agent.name,
                agent_card_url=root_agent.agent_card_url,
                timeout=timeout,
                description=root_agent.description
                or f"A2A Agent for {root_agent.name}",
                sub_agents=sub_agents,
            )

            logger.info(
                f"A2A agent created successfully: {root_agent.name} ({root_agent.agent_card_url})"
            )

            return a2a_agent, None

        except Exception as e:
            logger.error(f"Error building A2A agent: {str(e)}")
            raise ValueError(f"Error building A2A agent: {str(e)}")

    async def build_workflow_agent(
        self, root_agent
    ) -> Tuple[WorkflowAgent, Optional[AsyncExitStack]]:
        """Build a workflow agent with its sub-agents."""
        logger.info(f"Creating Workflow agent from {root_agent.name}")

        agent_config = root_agent.config or {}

        if not agent_config.get("workflow"):
            raise ValueError("workflow is required for workflow agents")

        try:
            sub_agents = []
            if root_agent.config.get("sub_agents"):
                sub_agents_with_stacks = await self._get_sub_agents(
                    root_agent.config.get("sub_agents")
                )
                sub_agents = [agent for agent, _ in sub_agents_with_stacks]

            config = root_agent.config or {}
            timeout = config.get("timeout", 300)

            workflow_agent = WorkflowAgent(
                name=root_agent.name,
                flow_json=agent_config.get("workflow"),
                timeout=timeout,
                description=root_agent.description
                or f"Workflow Agent for {root_agent.name}",
                sub_agents=sub_agents,
                db=self.db,
            )

            logger.info(f"Workflow agent created successfully: {root_agent.name}")

            return workflow_agent, None

        except Exception as e:
            logger.error(f"Error building Workflow agent: {str(e)}")
            raise ValueError(f"Error building Workflow agent: {str(e)}")

    async def build_task_agent(
        self, root_agent
    ) -> Tuple[TaskAgent, Optional[AsyncExitStack]]:
        """Build a task agent with its sub-agents."""
        logger.info(f"Creating Task agent: {root_agent.name}")

        agent_config = root_agent.config or {}

        if not agent_config.get("tasks"):
            raise ValueError("tasks are required for Task agents")

        try:
            # Get sub-agents if there are any
            sub_agents = []
            if root_agent.config.get("sub_agents"):
                sub_agents_with_stacks = await self._get_sub_agents(
                    root_agent.config.get("sub_agents")
                )
                sub_agents = [agent for agent, _ in sub_agents_with_stacks]

            # Additional configurations
            config = root_agent.config or {}

            # Convert tasks to the expected format by TaskAgent
            tasks = []
            for task_config in config.get("tasks", []):
                task = AgentTask(
                    agent_id=task_config.get("agent_id"),
                    description=task_config.get("description", ""),
                    expected_output=task_config.get("expected_output", ""),
                    enabled_tools=task_config.get("enabled_tools", []),
                )
                tasks.append(task)

            # Create the Task agent
            task_agent = TaskAgent(
                name=root_agent.name,
                tasks=tasks,
                db=self.db,
                sub_agents=sub_agents,
            )

            logger.info(f"Task agent created successfully: {root_agent.name}")

            return task_agent, None

        except Exception as e:
            logger.error(f"Error building Task agent: {str(e)}")
            raise ValueError(f"Error building Task agent: {str(e)}")

    async def build_composite_agent(self, agent: Agent) -> Tuple[BaseAgent, Optional[AsyncExitStack]]:
        """Build composite agents like sequential, parallel, loop."""
        sub_agents_with_stacks = await self._get_sub_agents(agent.config.get("sub_agents", []))
        sub_agents = [sa for sa, _ in sub_agents_with_stacks]
        if agent.type == "sequential":
            return SequentialAgent(agents=sub_agents), None
        elif agent.type == "parallel":
            return ParallelAgent(agents=sub_agents), None
        elif agent.type == "loop":
            return LoopAgent(agent=sub_agents[0], max_loops=agent.config.get("max_loops", 5)), None
        else:
            raise ValueError(f"Unknown composite agent type: {agent.type}")

    async def build_agent(self, agent: Agent) -> Tuple[BaseAgent, Optional[AsyncExitStack]]:
        """Main method to build any agent type."""
        if agent.type == "llm":
            return await self.build_llm_agent(agent)
        elif agent.type == "a2a":
            return await self.build_a2a_agent(agent)
        elif agent.type == "workflow":
            return await self.build_workflow_agent(agent)
        elif agent.type == "task":
            return await self.build_task_agent(agent)
        elif agent.type in ["sequential", "parallel", "loop"]:
            return await self.build_composite_agent(agent)
        else:
            raise ValueError(f"Invalid agent type: {agent.type}")
2. 修改 src/services/adk/agent_runner.py（解析响应为 A2UI 或文本）
添加 JSON 解析逻辑，如果响应是有效 A2UI JSON，则返回带类型的字典。
Python"""
┌──────────────────────────────────────────────────────────────────────────────┐
│ @author: Davidson Gomes                                                      │
│ @file: agent_runner.py                                                       │
│ Developed by: Davidson Gomes                                                 │
│ Creation date: May 13, 2025                                                  │
│ Contact: contato@evolution-api.com                                           │
├──────────────────────────────────────────────────────────────────────────────┤
│ @copyright © Evolution API 2025. All rights reserved.                        │
│ Licensed under the Apache License, Version 2.0                               │
│                                                                              │
│ You may not use this file except in compliance with the License.             │
│ You may obtain a copy of the License at                                      │
│                                                                              │
│    http://www.apache.org/licenses/LICENSE-2.0                                │
│                                                                              │
│ Unless required by applicable law or agreed to in writing, software          │
│ distributed under the License is distributed on an "AS IS" BASIS,            │
│ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.     │
│ See the License for the specific language governing permissions and          │
│ limitations under the License.                                               │
├──────────────────────────────────────────────────────────────────────────────┤
│ @important                                                                   │
│ For any future changes to the code in this file, it is recommended to        │
│ include, together with the modification, the information of the developer    │
│ who changed it and the date of modification.                                 │
└──────────────────────────────────────────────────────────────────────────────┘
"""

from google.adk.runners import Runner
from google.genai.types import Content, Part, Blob
from google.adk.sessions import DatabaseSessionService
from google.adk.memory import InMemoryMemoryService
from google.adk.artifacts.in_memory_artifact_service import InMemoryArtifactService
from src.utils.logger import setup_logger
from src.core.exceptions import AgentNotFoundError, InternalServerError
from src.services.agent_service import get_agent
from src.services.adk.agent_builder import AgentBuilder
from sqlalchemy.orm import Session
from typing import Optional, AsyncGenerator
import asyncio
import json
from src.utils.otel import get_tracer
from opentelemetry import trace
import base64

logger = setup_logger(__name__)

async def run_agent(
    agent_id: str,
    external_id: str,
    message: str,
    session_service: DatabaseSessionService,
    artifacts_service: InMemoryArtifactService,
    memory_service: InMemoryMemoryService,
    db: Session,
    session_id: Optional[str] = None,
    timeout: float = 60.0,
    files: Optional[list] = None,
):
    tracer = get_tracer()
    with tracer.start_as_current_span(
        "run_agent",
        attributes={
            "agent_id": agent_id,
            "external_id": external_id,
            "session_id": session_id or f"{external_id}_{agent_id}",
            "message": message,
            "has_files": files is not None and len(files) > 0,
        },
    ):
        exit_stack = None
        try:
            logger.info(
                f"Starting execution of agent {agent_id} for external_id {external_id}"
            )
            logger.info(f"Received message: {message}")

            if files and len(files) > 0:
                logger.info(f"Received {len(files)} files with message")

            get_root_agent = get_agent(db, agent_id)
            logger.info(
                f"Root agent found: {get_root_agent.name} (type: {get_root_agent.type})"
            )

            if get_root_agent is None:
                raise AgentNotFoundError(f"Agent with ID {agent_id} not found")

            # Using the AgentBuilder to create the agent
            agent_builder = AgentBuilder(db)
            root_agent, exit_stack = await agent_builder.build_agent(get_root_agent)

            logger.info("Configuring Runner")
            agent_runner = Runner(
                agent=root_agent,
                app_name=agent_id,
                session_service=session_service,
                artifact_service=artifacts_service,
                memory_service=memory_service,
            )
            adk_session_id = f"{external_id}_{agent_id}"
            if session_id is None:
                session_id = adk_session_id

            logger.info(f"Searching session for external_id {external_id}")
            session = session_service.get_session(
                app_name=agent_id,
                user_id=external_id,
                session_id=adk_session_id,
            )

            if session is None:
                logger.info(f"Creating new session for external_id {external_id}")
                session = session_service.create_session(
                    app_name=agent_id,
                    user_id=external_id,
                    session_id=adk_session_id,
                )

            file_parts = []
            if files and len(files) > 0:
                for file_data in files:
                    try:
                        file_bytes = base64.b64decode(file_data.data)

                        logger.info(f"DEBUG - Processing file: {file_data.filename}")
                        logger.info(f"DEBUG - File size: {len(file_bytes)} bytes")
                        logger.info(f"DEBUG - MIME type: '{file_data.content_type}'")
                        logger.info(f"DEBUG - First 20 bytes: {file_bytes[:20]}")

                        try:
                            file_part = Part(
                                inline_data=Blob(
                                    mime_type=file_data.content_type, data=file_bytes
                                )
                            )
                            logger.info(
                                f"DEBUG - Part created successfully"
                            )
                        except Exception as part_error:
                            logger.error(
                                f"DEBUG - Error creating Part: {str(part_error)}"
                            )
                            logger.error(
                                f"DEBUG - Error type: {type(part_error).__name__}"
                            )
                            import traceback

                            logger.error(
                                f"DEBUG - Stack trace: {traceback.format_exc()}"
                            )
                            raise

                        # Save the file in the ArtifactService
                        version = artifacts_service.save_artifact(
                            app_name=agent_id,
                            user_id=external_id,
                            session_id=adk_session_id,
                            filename=file_data.filename,
                            artifact=file_part,
                        )
                        logger.info(
                            f"Saved file {file_data.filename} as version {version}"
                        )

                        # Add the Part to the list of parts for the message content
                        file_parts.append(file_part)
                    except Exception as e:
                        logger.error(
                            f"Error processing file {file_data.filename}: {str(e)}"
                        )

            # Create the content with the text message and the files
            parts = [Part(text=message)]
            if file_parts:
                parts.extend(file_parts)

            content = Content(role="user", parts=parts)
            logger.info("Starting agent execution")

            final_response = {"type": "text", "content": "No final response captured."}
            message_history = []

            try:
                response_queue = asyncio.Queue()
                execution_completed = asyncio.Event()

                async def process_events():
                    try:
                        events_async = agent_runner.run_async(
                            user_id=external_id,
                            session_id=adk_session_id,
                            new_message=content,
                        )

                        last_response = None
                        all_responses = []

                        async for event in events_async:
                            if event.content and event.content.parts:
                                event_dict = event.dict()
                                event_dict = convert_sets(event_dict)
                                message_history.append(event_dict)

                            if (
                                event.content
                                and event.content.parts
                                and event.content.parts[0].text
                            ):
                                current_text = event.content.parts[0].text
                                last_response = current_text
                                all_responses.append(current_text)

                            if event.actions and event.actions.escalate:
                                escalate_text = f"Agent escalated: {event.error_message or 'No specific message.'}"
                                await response_queue.put(escalate_text)
                                execution_completed.set()
                                return

                        if last_response:
                            await response_queue.put(last_response)
                        else:
                            await response_queue.put(
                                "Finished without specific response"
                            )

                        execution_completed.set()
                    except Exception as e:
                        logger.error(f"Error in process_events: {str(e)}")
                        await response_queue.put(f"Error: {str(e)}")
                        execution_completed.set()

                task = asyncio.create_task(process_events())

                try:
                    wait_task = asyncio.create_task(execution_completed.wait())
                    done, pending = await asyncio.wait({wait_task}, timeout=timeout)

                    for p in pending:
                        p.cancel()

                    if not execution_completed.is_set():
                        logger.warning(
                            f"Agent execution timed out after {timeout} seconds"
                        )
                        await response_queue.put(
                            "The response took too long and was interrupted."
                        )

                    final_response_text = await response_queue.get()

                    # 解析响应为 A2UI 或文本
                    try:
                        parsed = json.loads(final_response_text)
                        if parsed.get("type") == "a2ui" and "content" in parsed and isinstance(parsed["content"], dict) and "components" in parsed["content"]:
                            final_response = parsed
                        else:
                            final_response = {"type": "text", "content": final_response_text}
                    except json.JSONDecodeError:
                        final_response = {"type": "text", "content": final_response_text}

                except Exception as e:
                    logger.error(f"Error waiting for response: {str(e)}")
                    final_response = {"type": "text", "content": f"Error processing response: {str(e)}"}

                # Add the session to memory after completion
                completed_session = session_service.get_session(
                    app_name=agent_id,
                    user_id=external_id,
                    session_id=adk_session_id,
                )

                memory_service.add_session_to_memory(completed_session)

                # Cancel the processing task if it is still running
                if not task.done():
                    task.cancel()
                    try:
                        await task
                    except asyncio.CancelledError:
                        logger.info("Task cancelled successfully")
                    except Exception as e:
                        logger.error(f"Error cancelling task: {str(e)}")

            except Exception as e:
                logger.error(f"Error processing request: {str(e)}")
                raise InternalServerError(str(e)) from e

            logger.info("Agent execution completed successfully")
            return {
                "final_response": final_response,
                "message_history": message_history,
            }
        except AgentNotFoundError as e:
            logger.error(f"Error processing request: {str(e)}")
            raise e
        except Exception as e:
            logger.error(f"Internal error processing request: {str(e)}", exc_info=True)
            raise InternalServerError(str(e))
        finally:
            # Clean up MCP connection - MUST be executed in the same task
            if exit_stack:
                logger.info("Closing MCP server connection...")
                try:
                    await exit_stack.aclose()
                except Exception as e:
                    logger.error(f"Error closing MCP connection: {e}")
                    # Do not raise the exception to not obscure the original error

def convert_sets(obj):
    if isinstance(obj, set):
        return list(obj)
    elif isinstance(obj, dict):
        return {k: convert_sets(v) for k, v in obj.items()}
    elif isinstance(obj, list):
        return [convert_sets(i) for i in obj]
    else:
        return obj

async def run_agent_stream(
    agent_id: str,
    external_id: str,
    message: str,
    session_service: DatabaseSessionService,
    artifacts_service: InMemoryArtifactService,
    memory_service: InMemoryMemoryService,
    db: Session,
    session_id: Optional[str] = None,
    files: Optional[list] = None,
) -> AsyncGenerator[str, None]:
    tracer = get_tracer()
    span = tracer.start_span(
        "run_agent_stream",
        attributes={
            "agent_id": agent_id,
            "external_id": external_id,
            "session_id": session_id or f"{external_id}_{agent_id}",
            "message": message,
            "has_files": files is not None and len(files) > 0,
        },
    )
    try:
        with trace.use_span(span, end_on_exit=True):
            try:
                logger.info(
                    f"Starting streaming execution of agent {agent_id} for external_id {external_id}"
                )
                logger.info(f"Received message: {message}")

                if files and len(files) > 0:
                    logger.info(f"Received {len(files)} files with message")

                get_root_agent = get_agent(db, agent_id)
                logger.info(
                    f"Root agent found: {get_root_agent.name} (type: {get_root_agent.type})"
                )

                if get_root_agent is None:
                    raise AgentNotFoundError(f"Agent with ID {agent_id} not found")

                # Using the AgentBuilder to create the agent
                agent_builder = AgentBuilder(db)
                root_agent, exit_stack = await agent_builder.build_agent(get_root_agent)

                logger.info("Configuring Runner")
                agent_runner = Runner(
                    agent=root_agent,
                    app_name=agent_id,
                    session_service=session_service,
                    artifact_service=artifacts_service,
                    memory_service=memory_service,
                )
                adk_session_id = f"{external_id}_{agent_id}"
                if session_id is None:
                    session_id = adk_session_id

                logger.info(f"Searching session for external_id {external_id}")
                session = session_service.get_session(
                    app_name=agent_id,
                    user_id=external_id,
                    session_id=adk_session_id,
                )

                if session is None:
                    logger.info(f"Creating new session for external_id {external_id}")
                    session = session_service.create_session(
                        app_name=agent_id,
                        user_id=external_id,
                        session_id=adk_session_id,
                    )

                # Process the received files
                file_parts = []
                if files and len(files) > 0:
                    for file_data in files:
                        try:
                            # Decode the base64 file
                            file_bytes = base64.b64decode(file_data.data)

                            # Detailed debug
                            logger.info(
                                f"DEBUG - Processing file: {file_data.filename}"
                            )
                            logger.info(f"DEBUG - File size: {len(file_bytes)} bytes")
                            logger.info(
                                f"DEBUG - MIME type: '{file_data.content_type}'"
                            )
                            logger.info(f"DEBUG - First 20 bytes: {file_bytes[:20]}")

                            # Create a Part for the file using the default constructor
                            try:
                                file_part = Part(
                                    inline_data=Blob(
                                        mime_type=file_data.content_type,
                                        data=file_bytes,
                                    )
                                )
                                logger.info(f"DEBUG - Part created successfully")
                            except Exception as part_error:
                                logger.error(
                                    f"DEBUG - Error creating Part: {str(part_error)}"
                                )
                                logger.error(
                                    f"DEBUG - Error type: {type(part_error).__name__}"
                                )
                                import traceback

                                logger.error(
                                    f"DEBUG - Stack trace: {traceback.format_exc()}"
                                )
                                raise

                            # Save the file in the ArtifactService
                            version = artifacts_service.save_artifact(
                                app_name=agent_id,
                                user_id=external_id,
                                session_id=adk_session_id,
                                filename=file_data.filename,
                                artifact=file_part,
                            )
                            logger.info(
                                f"Saved file {file_data.filename} as version {version}"
                            )

                            # Add the Part to the list of parts for the message content
                            file_parts.append(file_part)
                        except Exception as e:
                            logger.error(
                                f"Error processing file {file_data.filename}: {str(e)}"
                            )

                # Create the content with the text message and the files
                parts = [Part(text=message)]
                if file_parts:
                    parts.extend(file_parts)

                content = Content(role="user", parts=parts)

                # 执行流式响应，并解析每个 chunk
                events_async = agent_runner.run_async(
                    user_id=external_id,
                    session_id=adk_session_id,
                    new_message=content,
                )

                async for event in events_async:
                    if event.content and event.content.parts and event.content.parts[0].text:
                        chunk_text = event.content.parts[0].text
                        try:
                            parsed = json.loads(chunk_text)
                            if parsed.get("type") == "a2ui" and "content" in parsed:
                                yield json.dumps(parsed)
                            else:
                                yield json.dumps({"type": "text", "content": chunk_text})
                        except json.JSONDecodeError:
                            yield json.dumps({"type": "text", "content": chunk_text})

            except Exception as e:
                logger.error(f"Error in streaming: {str(e)}")
                yield json.dumps({"type": "text", "content": f"Error: {str(e)"})

            finally:
                if exit_stack:
                    await exit_stack.aclose()

    except Exception as e:
        logger.error(f"Stream error: {str(e)}")
3. 修改 src/api/chat_routes.py（处理 A2UI 响应）
修改返回以支持类型化响应，并更新 schemas 如果需要（假设 schemas.ChatResponse 支持 dict）。
Python"""
┌──────────────────────────────────────────────────────────────────────────────┐
│ @author: Davidson Gomes                                                      │
│ @file: chat_routes.py                                                        │
│ Developed by: Davidson Gomes                                                 │
│ Creation date: May 13, 2025                                                  │
│ Contact: contato@evolution-api.com                                           │
├──────────────────────────────────────────────────────────────────────────────┤
│ @copyright © Evolution API 2025. All rights reserved.                        │
│ Licensed under the Apache License, Version 2.0                               │
│                                                                              │
│ You may not use this file except in compliance with the License.             │
│ You may obtain a copy of the License at                                      │
│                                                                              │
│    http://www.apache.org/licenses/LICENSE-2.0                                │
│                                                                              │
│ Unless required by applicable law or agreed to in writing, software          │
│ distributed under the License is distributed on an "AS IS" BASIS,            │
│ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.     │
│ See the License for the specific language governing permissions and          │
│ limitations under the License.                                               │
├──────────────────────────────────────────────────────────────────────────────┤
│ @important                                                                   │
│ For any future changes to the code in this file, it is recommended to        │
│ include, together with the modification, the information of the developer    │
│ who changed it and the date of modification.                                 │
└──────────────────────────────────────────────────────────────────────────────┘
"""

import uuid
import base64
from fastapi import (
    APIRouter,
    Depends,
    HTTPException,
    status,
    WebSocket,
    WebSocketDisconnect,
    Header,
)
from sqlalchemy.orm import Session
from src.config.settings import settings
from src.config.database import get_db
from src.core.jwt_middleware import (
    get_jwt_token,
    verify_user_client,
    get_jwt_token_ws,
)
from src.services import (
    agent_service,
)
from src.schemas.chat import ChatRequest, ChatResponse, ErrorResponse, FileData
from src.services.adk.agent_runner import run_agent as run_agent_adk, run_agent_stream
from src.services.crewai.agent_runner import run_agent as run_agent_crewai
from src.core.exceptions import AgentNotFoundError
from src.services.service_providers import (
    session_service,
    artifacts_service,
    memory_service,
)

from datetime import datetime
import logging
import json
from typing import Optional, Dict, List, Any

logger = logging.getLogger(__name__)

router = APIRouter(
    prefix="/chat",
    tags=["chat"],
    responses={404: {"description": "Not found"}},
)

async def get_agent_by_api_key(
    agent_id: str,
    api_key: Optional[str] = Header(None, alias="x-api-key"),
    authorization: Optional[str] = Header(None),
    db: Session = Depends(get_db),
):
    """Flexible authentication for chat routes, allowing JWT or API key"""
    if authorization:
        # Try to authenticate with JWT token first
        try:
            # Extract token from Authorization header if needed
            token = (
                authorization.replace("Bearer ", "")
                if authorization.startswith("Bearer ")
                else authorization
            )
            payload = await get_jwt_token(token)
            agent = agent_service.get_agent(db, agent_id)
            if not agent:
                raise HTTPException(
                    status_code=status.HTTP_404_NOT_FOUND,
                    detail="Agent not found",
                )

            # Verify if the user has access to the agent's client
            await verify_user_client(payload, db, agent.client_id)
            return agent
        except Exception as e:
            logger.warning(f"JWT authentication failed: {str(e)}")
            # If JWT fails, continue to try with API key

    # Try to authenticate with API key
    if not api_key:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Authentication required (JWT or API key)",
        )

    agent = agent_service.get_agent(db, agent_id)
    if not agent or not agent.config:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND, detail="Agent not found"
        )

    # Verify if the API key matches
    if not agent.config.get("api_key") or agent.config.get("api_key") != api_key:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED, detail="Invalid API key"
        )

    return agent

@router.websocket("/ws/{agent_id}/{external_id}")
async def websocket_chat(
    websocket: WebSocket,
    agent_id: str,
    external_id: str,
    db: Session = Depends(get_db),
):
    try:
        # Accept the connection
        await websocket.accept()
        logger.info("WebSocket connection accepted, waiting for authentication")

        # Wait for authentication message
        try:
            auth_data = await websocket.receive_json()
            logger.info(f"Authentication data received: {auth_data}")

            if not (
                auth_data.get("type") == "authorization"
                and (auth_data.get("token") or auth_data.get("api_key"))
            ):
                logger.warning("Invalid authentication message")
                await websocket.close(code=status.WS_1008_POLICY_VIOLATION)
                return

            # Verify if the agent exists
            agent = agent_service.get_agent(db, agent_id)
            if not agent:
                logger.warning(f"Agent {agent_id} not found")
                await websocket.close(code=status.WS_1008_POLICY_VIOLATION)
                return

            # Verify authentication
            is_authenticated = False

            # Try with JWT token
            if auth_data.get("token"):
                try:
                    payload = await get_jwt_token_ws(auth_data["token"])
                    if payload:
                        # Verify if the user has access to the agent
                        await verify_user_client(payload, db, agent.client_id)
                        is_authenticated = True
                except Exception as e:
                    logger.warning(f"JWT authentication failed: {str(e)}")

            # If JWT fails, try with API key
            if not is_authenticated and auth_data.get("api_key"):
                if agent.config and agent.config.get("api_key") == auth_data.get(
                    "api_key"
                ):
                    is_authenticated = True
                else:
                    logger.warning("Invalid API key")

            if not is_authenticated:
                await websocket.close(code=status.WS_1008_POLICY_VIOLATION)
                return

            logger.info(
                f"WebSocket connection established for agent {agent_id} and external_id {external_id}"
            )

            while True:
                try:
                    data = await websocket.receive_json()
                    logger.info(f"Received message: {data}")
                    message = data.get("message")

                    if not message:
                        continue

                    files = None
                    if data.get("files") and isinstance(data.get("files"), list):
                        try:
                            files = []
                            for file_data in data.get("files"):
                                if (
                                    isinstance(file_data, dict)
                                    and file_data.get("filename")
                                    and file_data.get("content_type")
                                    and file_data.get("data")
                                ):
                                    files.append(
                                        FileData(
                                            filename=file_data.get("filename"),
                                            content_type=file_data.get("content_type"),
                                            data=file_data.get("data"),
                                        )
                                    )
                            logger.info(
                                f"Processed {len(files)} files via WebSocket"
                            )
                        except Exception as e:
                            logger.error(f"Error processing files: {str(e)}")
                            files = None

                    async for chunk in run_agent_stream(
                        agent_id=agent_id,
                        external_id=external_id,
                        message=message,
                        session_service=session_service,
                        artifacts_service=artifacts_service,
                        memory_service=memory_service,
                        db=db,
                        files=files,
                    ):
                        await websocket.send_json(
                            {"message": json.loads(chunk), "turn_complete": False}
                        )

                    # Send signal of complete turn
                    await websocket.send_json({"message": "", "turn_complete": True})

                except WebSocketDisconnect:
                    logger.info("Client disconnected")
                    break
                except json.JSONDecodeError:
                    logger.warning("Invalid JSON message received")
                    continue
                except Exception as e:
                    logger.error(f"Error in WebSocket message handling: {str(e)}")
                    await websocket.close(code=status.WS_1011_INTERNAL_ERROR)
                    break

        except WebSocketDisconnect:
            logger.info("Client disconnected during authentication")
        except json.JSONDecodeError:
            logger.warning("Invalid authentication message format")
            await websocket.close(code=status.WS_1008_POLICY_VIOLATION)
        except Exception as e:
            logger.error(f"Error during authentication: {str(e)}")
            await websocket.close(code=status.WS_1011_INTERNAL_ERROR)

    except Exception as e:
        logger.error(f"WebSocket error: {str(e)}")
        await websocket.close(code=status.WS_1011_INTERNAL_ERROR)

@router.post(
    "/{agent_id}/{external_id}",
    response_model=Dict[str, Any],  # 修改为支持 dict 返回
    responses={
        400: {"model": ErrorResponse},
        404: {"model": ErrorResponse},
        500: {"model": ErrorResponse},
    },
)
async def chat(
    request: ChatRequest,
    agent_id: str,
    external_id: str,
    _=Depends(get_agent_by_api_key),
    db: Session = Depends(get_db),
):
    try:
        if settings.AI_ENGINE == "adk":
            final_response = await run_agent_adk(
                agent_id,
                external_id,
                request.message,
                session_service,
                artifacts_service,
                memory_service,
                db,
                files=request.files,
            )
        elif settings.AI_ENGINE == "crewai":
            final_response = await run_agent_crewai(
                agent_id,
                external_id,
                request.message,
                session_service,
                db,
                files=request.files,
            )

        return {
            "response": final_response["final_response"],  # 现在是 {"type": ..., "content": ...}
            "message_history": final_response["message_history"],
            "status": "success",
            "timestamp": datetime.now().isoformat(),
        }

    except AgentNotFoundError as e:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(e)) from e
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=str(e)
        ) from e
4. 前端代码（假设 frontend/src/app/chat/page.tsx 和 frontend/src/components/A2UIRenderer.tsx）
由于仓库前端文件未提取到，我提供标准 Next.js 实现。添加依赖：npm install @lit/react lit（用于 A2UI 渲染适配）。

frontend/src/components/A2UIRenderer.tsx（新文件）

TypeScriptimport React from 'react';

// 组件映射
const componentMap: { [key: string]: React.FC<any> } = {
  text: ({ content, style }) => <p style={style}>{content}</p>,
  button: ({ label, action, style }) => (
    <button
      style={style}
      onClick={() => {
        if (action.type === 'callback') {
          // 发送回调到后端
          console.log(`Handling action: ${action.handler}`);
          // 示例: fetch('/api/chat/...', { body: JSON.stringify({ action: action.handler }) })
        }
      }}
    >
      {label}
    </button>
  ),
  card: ({ title, content, style }) => (
    <div style={{ ...style, border: '1px solid #ddd', padding: '16px', borderRadius: '8px' }}>
      {title && <h3>{title}</h3>}
      {content.map((c: any) => <A2UIRenderer key={c.id} component={c} />)}
    </div>
  ),
  form: ({ fields, actions, style }) => (
    <form style={style}>
      {fields.map((field: any) => <A2UIRenderer key={field.id} component={field} />)}
      {actions.map((action: any) => <A2UIRenderer key={action.id} component={action} />)}
    </form>
  ),
  'text-field': ({ label, required, style }) => (
    <div>
      <label>{label}{required ? '*' : ''}</label>
      <input type="text" style={style} required={required} />
    </div>
  ),
  // 添加更多 A2UI 组件
};

interface A2UIRendererProps {
  component: any;
}

const A2UIRenderer: React.FC<A2UIRendererProps> = ({ component }) => {
  const { type, style, ...props } = component;
  const Component = componentMap[type];
  if (!Component) return null;
  return <Component {...props} style={style} />;
};

export default A2UIRenderer;

frontend/src/app/chat/page.tsx（假设聊天页面）

TypeScript'use client';

import React, { useState } from 'react';
import A2UIRenderer from '@/components/A2UIRenderer';

const ChatPage = () => {
  const [messages, setMessages] = useState<any[]>([]);
  const [input, setInput] = useState('');

  const sendMessage = async () => {
    if (!input) return;

    setMessages([...messages, { role: 'user', content: input }]);
    setInput('');

    try {
      const res = await fetch('/api/chat/{agent_id}/{external_id}', {  // 替换为实际端点
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ message: input }),
      });
      const data = await res.json();
      setMessages((prev) => [...prev, { role: 'bot', ...data.response }]);  // 使用 data.response
    } catch (error) {
      console.error('Error:', error);
    }
  };

  return (
    <div>
      <div className="chat-window">
        {messages.map((msg, idx) => (
          <div key={idx} className={msg.role}>
            {msg.role === 'bot' && msg.type === 'a2ui' ? (
              msg.content.components.map((comp: any) => (
                <A2UIRenderer key={comp.id} component={comp} />
              ))
            ) : (
              <p>{msg.content}</p>
            )}
          </div>
        ))}
      </div>
      <input value={input} onChange={(e) => setInput(e.target.value)} />
      <button onClick={sendMessage}>Send</button>
    </div>
  );
};

export default ChatPage;
测试和扩展

测试：运行 docker-compose up，创建 LLM Agent，聊天输入如 "Show a form for login"，响应应为 A2UI JSON 并在前端渲染。
挑战：如果 LLM 不严格输出 JSON，添加更多提示或使用 LLM 的 JSON mode（Gemini 支持）。
扩展：为流式响应（websocket）添加类似解析；集成 AgentSkills 如之前对话。

如果需要更多文件或调整，提供细节。这是前端仓库https://github.com/EvolutionAPI/evo-ai/tree/main/frontend，如何添加A2UI在 Evo AI 前端（Next.js + shadcn/ui + Tailwind）中整合 A2UI 的完整指南
Evo AI 的前端仓库位于：
https://github.com/EvolutionAPI/evo-ai/tree/main/frontend
这是一个标准的 Next.js 15 App Router 项目，使用 TypeScript、Tailwind CSS、shadcn/ui 组件库、React Query 等现代技术栈。聊天界面通常位于类似 /app/chat/[agent_id]/[session_id]/page.tsx 或 /components/chat/Chat.tsx 的位置（具体路径可能因版本略有不同，但聊天消息渲染逻辑基本都在一个主要聊天组件中）。
目前（2026年1月）Google 的 A2UI（Agent-to-User Interface）协议官方还没有发布成熟的 React/Next.js 原生渲染器（预计 Q1 2026 才会比较完善），但我们可以通过以下两种实用方式来整合：

推荐方式：自己实现一个轻量级 A2UIRenderer 组件（目前最实际、最快的方式）
未来方式：等官方 React 渲染器发布后替换（或使用 CopilotKit/AG UI 这种已经支持 A2UI 的框架）

下面重点讲解 方式1 的完整实现步骤（最适合当前 Evo AI 项目）。
步骤 1：理解 Evo AI 聊天响应结构
后端返回的响应结构大概是这样的（根据之前的修改）：
JSON{
  "response": {
    "type": "text" | "a2ui",
    "content": "普通文本"   // 或 { "components": [...] } A2UI JSON
  },
  "message_history": [...]
}
聊天组件需要根据 type 来决定是显示纯文本还是渲染 A2UI 组件树。
步骤 2：创建 A2UI 渲染器组件
在 frontend/src/components/ 下新建文件：A2UIRenderer.tsx
tsx// frontend/src/components/A2UIRenderer.tsx
'use client'

import React from 'react'

// A2UI 常用基础组件映射表（可根据需要不断扩展）
const componentRegistry: Record<string, React.FC<any>> = {
  // 基础文本
  text: ({ content, style = {} }) => (
    <p className="text-sm" style={style}>
      {content}
    </p>
  ),

  // 标题（可复用 text 或单独实现）
  heading: ({ level = 1, content, style = {} }) => {
    const Tag = `h${level}` as keyof JSX.IntrinsicElements
    return <Tag style={style}>{content}</Tag>
  },

  // 按钮（带交互）
  button: ({ label, action, style = {}, disabled = false }) => (
    <button
      className="px-4 py-2 bg-primary text-primary-foreground rounded-md hover:opacity-90 disabled:opacity-50"
      style={style}
      disabled={disabled}
      onClick={() => {
        if (action?.type === 'callback' && action.handler) {
          // 这里调用后端回调接口或更新状态
          console.log(`执行 A2UI 回调: ${action.handler}`)
          // 实际项目中可以 dispatch action 或 fetch('/api/callback', ...)
        }
      }}
    >
      {label}
    </button>
  ),

  // 卡片容器
  card: ({ title, content = [], style = {} }) => (
    <div
      className="border rounded-lg p-4 shadow-sm bg-card"
      style={style}
    >
      {title && <h3 className="text-lg font-semibold mb-2">{title}</h3>}
      <div className="space-y-3">
        {content.map((child: any, i: number) => (
          <A2UIRenderer key={child.id || i} component={child} />
        ))}
      </div>
    </div>
  ),

  // 输入框（简单版）
  'text-field': ({ label, placeholder, required, value, onChange, style = {} }) => (
    <div className="space-y-1">
      {label && <label className="text-sm font-medium">{label}</label>}
      <input
        type="text"
        placeholder={placeholder}
        required={required}
        value={value || ''}
        onChange={(e) => onChange?.(e.target.value)}
        className="w-full px-3 py-2 border rounded-md"
        style={style}
      />
    </div>
  ),

  // 表单容器（可包含多个 field + button）
  form: ({ fields = [], actions = [], style = {} }) => {
    const [formData, setFormData] = React.useState<Record<string, string>>({})

    return (
      <form
        className="space-y-4"
        style={style}
        onSubmit={(e) => {
          e.preventDefault()
          console.log('表单提交:', formData)
          // 可以在这里调用后端
        }}
      >
        {fields.map((field: any) => (
          <A2UIRenderer
            key={field.id}
            component={{
              ...field,
              value: formData[field.id] || '',
              onChange: (val: string) => setFormData(prev => ({ ...prev, [field.id]: val }))
            }}
          />
        ))}
        <div className="flex gap-3">
          {actions.map((action: any) => (
            <A2UIRenderer key={action.id} component={action} />
          ))}
        </div>
      </form>
    )
  },

  // 你可以继续添加更多组件：image, list, table, chart 等
}

interface A2UIRendererProps {
  component: any
}

export default function A2UIRenderer({ component }: A2UIRendererProps) {
  const { type, id, ...props } = component

  const Component = componentRegistry[type]

  if (!Component) {
    console.warn(`不支持的 A2UI 组件类型: ${type}`)
    return <div className="text-red-500 text-sm">[未知组件: {type}]</div>
  }

  return <Component {...props} />
}
步骤 3：修改聊天消息渲染组件
找到 Evo AI 的主要聊天消息显示组件（通常叫 ChatMessage、MessageBubble 或直接在 ChatWindow/ChatPage 中），修改成这样：
tsx// 示例：假设在 components/chat/ChatMessage.tsx 或类似位置
'use client'

import A2UIRenderer from '@/components/A2UIRenderer'

interface MessageProps {
  message: {
    role: 'user' | 'assistant'
    type?: 'text' | 'a2ui'
    content: string | { components: any[] }
  }
}

export function ChatMessage({ message }: MessageProps) {
  const isUser = message.role === 'user'

  return (
    <div className={`flex ${isUser ? 'justify-end' : 'justify-start'} mb-4`}>
      <div
        className={`
          max-w-[80%] rounded-lg p-4
          ${isUser 
            ? 'bg-primary text-primary-foreground' 
            : 'bg-muted'}
        `}
      >
        {message.type === 'a2ui' && typeof message.content === 'object' && 'components' in message.content ? (
          <div className="space-y-4">
            {message.content.components.map((comp: any, index: number) => (
              <A2UIRenderer key={comp.id || index} component={comp} />
            ))}
          </div>
        ) : (
          <div className="whitespace-pre-wrap">{String(message.content)}</div>
        )}
      </div>
    </div>
  )
}
步骤 4：常见 A2UI JSON 示例（供测试）
后端可以生成的几种典型 JSON：
JSON// 简单问候卡片
{
  "type": "a2ui",
  "content": {
    "components": [
      {
        "type": "card",
        "title": "欢迎使用 Evo AI",
        "content": [
          { "type": "text", "content": "今天我可以帮你做什么？" },
          { "type": "button", "label": "开始新任务", "action": { "type": "callback", "handler": "new_task" } }
        ]
      }
    ]
  }
}
JSON// 简单表单
{
  "type": "a2ui",
  "content": {
    "components": [
      {
        "type": "form",
        "fields": [
          { "type": "text-field", "id": "name", "label": "您的姓名" },
          { "type": "text-field", "id": "email", "label": "邮箱", "required": true }
        ],
        "actions": [
          { "type": "button", "label": "提交", "action": { "type": "callback", "handler": "submit_form" } }
        ]
      }
    ]
  }
}
步骤 5：推荐的后续优化方向（2026年现状）








































方案成熟度工作量推荐指数备注自己实现 Renderer（如上面）★★★★☆中★★★★★当前最实用，最可控等待官方 React Renderer★★☆☆☆低★★★★☆预计 Q1-Q2 2026 发布使用 CopilotKit + AG-UI★★★★☆高★★★☆☆功能最完整，但要重构部分聊天逻辑使用 Lit Web Components★★★☆☆中高★★☆☆☆需要桥接 React ↔ Web Components
总结一句话建议：
2026年1月现阶段最推荐的做法是：先自己写一个 A2UIRenderer（上面代码已经可以直接使用），快速验证效果，后续官方 React 渲染器出来后再逐步迁移。
需要帮助调整某个具体文件路径或增加更多组件类型支持，欢迎提供更多细节～20 sources在Evo ai的基础上，帮我完成所有的前端代码修改，要求，如果返回的是A2UI数据，聊天界面应该类似A2UI demo那样，在聊天界面右侧展示生成的UI界面，帮我完成所有的前端代码，后段代码，并给出到我完整整合 A2UI 到 Evo AI 的前后端代码修改
基于 Evo AI 仓库（https://github.com/EvolutionAPI/evo-ai），我已分析前端结构（app/ 目录下可能有 chat/ 相关页面，components/ 下有 UI 组件）。由于仓库前端代码是 Next.js App Router + shadcn/ui + Tailwind，我假设聊天界面在 app/chat/[agentId]/[externalId]/page.tsx 或类似（如果没有，创建它）。修改逻辑：

前端要求：聊天界面布局改为两列（flex 或 grid）。左侧显示聊天历史（消息气泡），右侧显示 A2UI 生成的 UI（类似 A2UI demo 的交互面板）。当后端返回 A2UI 数据时，更新右侧面板；否则右侧为空或隐藏。
A2UI 渲染：使用自定义 A2UIRenderer 组件，支持基本组件（text, button, card, form 等）。使用 shadcn/ui 风格保持一致。
后端：基于之前修改，确保响应格式为 {"type": "text" | "a2ui", "content": ...}。完善交互回调（button click 发送回后端）。

1. 后端代码修改（Python/FastAPI）
后端已部分整合 A2UI 生成逻辑。以下是完整文件（只显示修改部分；其他文件不变）。假设 AI_ENGINE=adk。

src/services/adk/agent_builder.py（添加 A2UI 提示，已有，无需再改）。
src/services/adk/agent_runner.py（解析响应为类型化 dict，已有）。添加回调处理支持（如果 button action，需要处理新输入）。修改 run_agent 函数，支持 A2UI 回调（但 A2UI 交互在前端处理，后端只需接收新消息）。Python# ... (原有代码)
# 在 final_response 解析后，如果是 a2ui，返回完整结构
final_response = {"type": "text", "content": final_response_text}
try:
    parsed = json.loads(final_response_text)
    if "type" in parsed and parsed["type"] == "a2ui" and "content" in parsed:
        final_response = parsed
except json.JSONDecodeError:
    pass
# ... (其余不变)
src/api/chat_routes.py（返回类型化响应，已有）。添加 WebSocket 支持 A2UI 流式（可选，但为完整性添加）。Python# ... (原有代码)
@router.post("/{agent_id}/{external_id}")
async def chat(
    request: ChatRequest,
    agent_id: str,
    external_id: str,
    _=Depends(get_agent_by_api_key),
    db: Session = Depends(get_db),
):
    # ... (调用 run_agent_adk)
    return {
        "response": final_response["final_response"],  # {"type": ..., "content": ...}
        "message_history": final_response["message_history"],
        "status": "success",
        "timestamp": datetime.now().isoformat(),
    }

# WebSocket 已支持流式，如果需要 A2UI 交互，客户端发送回调消息

后端完整：无需更多改动，后端主要生成 JSON，前端渲染和交互。
2. 前端代码修改（Next.js/TypeScript）
前端仓库结构：app/, components/, lib/ 等。修改/创建以下文件。

安装依赖（如果未有）：npm install (已有 shadcn/ui, Tailwind)。无需额外包。
创建 components/A2UIRenderer.tsx（新组件，渲染 A2UI JSON，使用 shadcn/ui 风格）。tsx// frontend/src/components/A2UIRenderer.tsx
'use client'

import React, { useState } from 'react'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { Label } from '@/components/ui/label'
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'

// A2UI 组件映射（使用 shadcn/ui 保持一致）
const componentRegistry: Record<string, React.FC<any>> = {
  text: ({ content, style = {} }) => <p className="text-sm text-muted-foreground" style={style}>{content}</p>,

  button: ({ label, action, style = {}, disabled = false, onAction }) => (
    <Button
      variant="default"
      disabled={disabled}
      style={style}
      onClick={() => {
        if (action?.type === 'callback' && action.handler) {
          onAction?.(action.handler)  // 回调到聊天组件，发送新消息到后端
        }
      }}
    >
      {label}
    </Button>
  ),

  card: ({ title, content = [], style = {} }) => (
    <Card style={style}>
      {title && <CardHeader><CardTitle>{title}</CardTitle></CardHeader>}
      <CardContent className="space-y-4">
        {content.map((child: any, i: number) => (
          <A2UIRenderer key={child.id || i} component={child} />
        ))}
      </CardContent>
    </Card>
  ),

  form: ({ fields = [], actions = [], style = {} }) => {
    const [formData, setFormData] = useState<Record<string, string>>({})

    return (
      <form style={style} className="space-y-4" onSubmit={(e) => e.preventDefault()}>
        {fields.map((field: any) => (
          <A2UIRenderer
            key={field.id}
            component={{
              ...field,
              value: formData[field.id] || '',
              onChange: (val: string) => setFormData(prev => ({ ...prev, [field.id]: val }))
            }}
          />
        ))}
        <div className="flex gap-2">
          {actions.map((action: any) => (
            <A2UIRenderer key={action.id} component={action} onAction={(handler: string) => {
              // 提交表单数据作为新消息
              console.log('Form submit:', formData)
              // onAction(handler, formData) // 如果需要传递数据
            }} />
          ))}
        </div>
      </form>
    )
  },

  'text-field': ({ label, placeholder, required, value, onChange, style = {} }) => (
    <div className="space-y-1">
      {label && <Label>{label}{required ? '*' : ''}</Label>}
      <Input
        type="text"
        placeholder={placeholder}
        required={required}
        value={value}
        onChange={(e) => onChange?.(e.target.value)}
        style={style}
      />
    </div>
  ),
  // 添加更多组件如 image, list 等
}

interface A2UIRendererProps {
  component: any
  onAction?: (handler: string, data?: any) => void  // 回调处理
}

const A2UIRenderer: React.FC<A2UIRendererProps> = ({ component, onAction }) => {
  const { type, id, ...props } = component
  const Component = componentRegistry[type]
  if (!Component) return <div className="text-red-500">未知组件: {type}</div>
  return <Component {...props} onAction={onAction} />
}

export default A2UIRenderer
修改/创建 app/chat/[agentId]/[externalId]/page.tsx（聊天页面，假设路径；如果不同，调整）。布局：flex 两列，左聊天，右 A2UI 面板。tsx// frontend/src/app/chat/[agentId]/[externalId]/page.tsx
'use client'

import React, { useState, useEffect } from 'react'
import { useParams } from 'next/navigation'
import A2UIRenderer from '@/components/A2UIRenderer'
import { Input } from '@/components/ui/input'
import { Button } from '@/components/ui/button'
import { ScrollArea } from '@/components/ui/scroll-area'

interface Message {
  role: 'user' | 'assistant'
  type?: 'text' | 'a2ui'
  content: string | { components: any[] }
}

const ChatPage = () => {
  const params = useParams()
  const agentId = params.agentId as string
  const externalId = params.externalId as string

  const [messages, setMessages] = useState<Message[]>([])
  const [input, setInput] = useState('')
  const [a2uiPanel, setA2uiPanel] = useState<any>(null)  // 右侧 A2UI 内容

  const sendMessage = async (message: string, isCallback = false) => {
    if (!message) return

    if (!isCallback) {
      setMessages(prev => [...prev, { role: 'user', content: message }])
    }

    try {
      const res = await fetch(`/api/chat/${agentId}/${externalId}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ message }),
      })
      const data = await res.json()
      const response = data.response

      setMessages(prev => [...prev, { role: 'assistant', ...response }])

      // 如果是 A2UI，更新右侧面板
      if (response.type === 'a2ui' && response.content?.components) {
        setA2uiPanel(response.content)
      }
    } catch (error) {
      console.error('Error:', error)
    }
  }

  const handleA2uiAction = (handler: string, data?: any) => {
    // 处理 A2UI 交互：发送回调作为新消息
    const callbackMessage = `A2UI callback: ${handler}${data ? ` with data ${JSON.stringify(data)}` : ''}`
    sendMessage(callbackMessage, true)
  }

  return (
    <div className="flex h-screen bg-background">
      {/* 左侧：聊天历史 */}
      <div className="w-1/2 border-r p-4 flex flex-col">
        <ScrollArea className="flex-1 mb-4">
          {messages.map((msg, idx) => (
            <div
              key={idx}
              className={`mb-4 ${msg.role === 'user' ? 'text-right' : 'text-left'}`}
            >
              <div
                className={`inline-block p-3 rounded-lg ${msg.role === 'user' ? 'bg-primary text-primary-foreground' : 'bg-muted'}`}
              >
                {msg.type === 'a2ui' && typeof msg.content === 'object' && 'components' in msg.content ? (
                  <p className="text-sm italic">A2UI 已渲染到右侧面板</p>
                ) : (
                  <p>{String(msg.content)}</p>
                )}
              </div>
            </div>
          ))}
        </ScrollArea>
        <div className="flex gap-2">
          <Input
            value={input}
            onChange={(e) => setInput(e.target.value)}
            placeholder="输入消息..."
            onKeyDown={(e) => e.key === 'Enter' && sendMessage(input)}
          />
          <Button onClick={() => sendMessage(input)}>发送</Button>
        </div>
      </div>

      {/* 右侧：A2UI 面板（类似 demo 的交互 UI） */}
      <div className="w-1/2 p-4 flex flex-col">
        <h2 className="text-lg font-semibold mb-4">交互 UI 面板</h2>
        <ScrollArea className="flex-1 border rounded-lg p-4 bg-card">
          {a2uiPanel ? (
            a2uiPanel.components.map((comp: any, i: number) => (
              <A2UIRenderer key={comp.id || i} component={comp} onAction={handleA2uiAction} />
            ))
          ) : (
            <p className="text-muted-foreground">等待 A2UI 响应...</p>
          )}
        </ScrollArea>
      </div>
    </div>
  )
}

export default ChatPage
其他文件：如果有 components/ChatMessage.tsx，集成到左侧渲染。但以上页面已完整。

3. 测试步骤

运行后端：docker-compose up。
运行前端：cd frontend && npm run dev。
访问 /chat/[agentId]/[externalId]，发送消息如 "Generate a form UI"，后端返回 A2UI 时，右侧显示交互面板。
交互：点击 button，前端发送回调消息，后端处理更新。

如果仓库结构不同（如无 chat/ 路径），创建它。完整代码已提供；如需调整，分享具体错误。
